<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1" name="viewport">
  </head>
  <body>
                <img src="images/logo@2x.png" id="navbar-logo" alt="Neovim">

    <div class="container">
      <h1>Vim documentation: msgpack_rpc</h1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>

		 NVIM REFERENCE MANUAL    by Thiago de Arruda



<A HREF="#RPC">RPC</A> <A HREF="api.html#API">API</A> for Nvim				     *<A NAME="RPC"></A><B>RPC</B>* *<A NAME="rpc"></A><B>rpc</B>* *<A NAME="msgpack-rpc"></A><B>msgpack-rpc</B>*

				      Type |<A HREF="various.html#gO">gO</A>| to see the table of contents.

==============================================================================

1. Introduction						            *<A NAME="rpc-intro"></A><B>rpc-intro</B>*

The primary way to <A HREF="intro.html#control">control</A> Nvim programmatically is the <A HREF="#RPC">RPC</A> <A HREF="api.html#API">API</A>, which speaks
MessagePack-RPC (&quot;msgpack-rpc&quot;), a messaging protocol that uses the
MessagePack serialization format:
  https://github.com/msgpack/msgpack/blob/0b8f5ac/spec.md

All kinds of Nvim &quot;clients&quot; use the <A HREF="#RPC">RPC</A> <A HREF="api.html#API">API</A>: user interfaces (GUIs), remote
plugins, scripts like &quot;nvr&quot; (https://github.com/mhinz/neovim-remote), and even
`nvim` itself can <A HREF="intro.html#control">control</A> other `nvim` instances. By connecting to the <A HREF="#RPC">RPC</A> <A HREF="api.html#API">API</A>
programs can:

  - Call any <A HREF="api.html#API">API</A> function
  - Listen for events
  - Receive remote calls from Nvim

The <A HREF="#RPC">RPC</A> <A HREF="api.html#API">API</A> is like a more powerful version of Vim's `clientserver` feature.

==============================================================================

2. <A HREF="api.html#API">API</A> <A HREF="map.html#mapping">mapping</A>							    *<A NAME="rpc-api"></A><B>rpc-api</B>*

The Nvim C |<A HREF="api.html#API">API</A>| is automatically exposed to the <A HREF="#RPC">RPC</A> API by the build system,
which parses headers at src/nvim/api/*. A dispatch function is generated which
matches <A HREF="#RPC">RPC</A> <A HREF="api.html#API">API</A> method names with public <A HREF="api.html#API">API</A> <A HREF="eval.html#functions">functions</A>, converting/validating
arguments and return values back to msgpack.

Client libraries (|<A HREF="#api-client">api-client</A>|<A HREF="change.html#s">s</A>) normally provide wrappers that hide
<A HREF="#msgpack-rpc">msgpack-rpc</A> details from application developers. The wrappers can be
automatically generated by reading bundled <A HREF="api.html#API">API</A> metadata from a compiled Nvim
instance.

There are three ways to obtain <A HREF="api.html#API">API</A> metadata:

  1. Connect to a running Nvim instance and call `nvim_get_api_info` via
     <A HREF="#msgpack-rpc">msgpack-rpc</A>. This is best for clients written in dynamic languages which
     can define <A HREF="eval.html#functions">functions</A> at runtime.

  2. Start Nvim with the |<A HREF="starting.html#--api-info">--api-info</A>| option. Useful for clients written in
     statically-compiled languages.

  3. Use the |<A HREF="eval.html#api_info()">api_info()</A>| vimscript function.

To get a human-readable <A HREF="eval.html#list">list</A> of <A HREF="api.html#API">API</A> <A HREF="eval.html#functions">functions</A>:
<B>    :new|put =map(api_info().functions, 'v:val.name')</B>
 
To get a formatted dump of the <A HREF="api.html#API">API</A> using <A HREF="if_pyth.html#python">python</A> (requires the `pyyaml` and
`msgpack-python` packages):
<B>    nvim --api-info | python -c 'import msgpack, sys, yaml; print yaml.dump(msgpack.unpackb(sys.stdin.read()))'</B>
 
==============================================================================

3. Connecting						      *<A NAME="rpc-connecting"></A><B>rpc-connecting</B>*

See |<A HREF="channel.html#channel-intro">channel-intro</A>|, for various ways to open a channel. Most of the channel
opening <A HREF="eval.html#functions">functions</A> take an `rpc` key in the <A HREF="options.html#options">options</A> dictionary, to enable <A HREF="#rpc">rpc</A>.

Additionally, <A HREF="#rpc">rpc</A> channels can be opened by other processes connecting to
TCP/IP sockets or named pipes listened to by <A HREF="nvim.html#nvim">nvim</A>.

An <A HREF="#rpc">rpc</A> socket is automatically created with each instance. The socket
 location is stored in |<A HREF="eval.html#v:servername">v:servername</A>|. By default this is a named pipe
with an automatically generated address. See |<A HREF="intro.html#XXX">XXX</A>|.

To make Nvim listen on a TCP/IP socket instead, specify YXXY--listen|:
<B>    nvim --listen 127.0.0.1:6666</B>
 Also, more sockets and named pipes can be listened on using |<A HREF="eval.html#serverstart()">serverstart()</A>|.

Note that localhost TCP sockets are generally <A HREF="various.html#less">less</A> secure than named pipes,
and can lead to vunerabilities like remote code execution.

Connecting to the socket is the easiest way a programmer can test the <A HREF="api.html#API">API</A>,
which can be done through any <A HREF="#msgpack-rpc">msgpack-rpc</A> client library or full-featured
|<A HREF="#api-client">api-client</A>|. Here's a <A HREF="if_ruby.html#Ruby">Ruby</A> <A HREF="usr_41.html#script">script</A> that prints 'hello world!' in the current
Nvim instance:

<B>    #!/usr/bin/env ruby</B>
<B>    # Requires msgpack-rpc: gem install msgpack-rpc</B>
<B>    #</B>
<B>    # To run this script, execute it from a running Nvim instance (notice the</B>
<B>    # trailing '&amp;' which is required since Nvim won't process events while</B>
<B>    # running a blocking command):</B>
<B>    #</B>
<B>    #	:!./hello.rb &amp;</B>
<B>    #</B>
<B>    # Or from another shell by setting NVIM_LISTEN_ADDRESS:</B>
<B>    # $ NVIM_LISTEN_ADDRESS=[address] ./hello.rb</B>

<B>    require 'msgpack/rpc'</B>
<B>    require 'msgpack/rpc/transport/unix'</B>

<B>    nvim = MessagePack::RPC::Client.new(MessagePack::RPC::UNIXTransport.new, ENV['NVIM_LISTEN_ADDRESS'])</B>
<B>    result = nvim.call(:nvim_command, 'echo "hello world!"')</B>
 
A better way is to use the <A HREF="if_pyth.html#Python">Python</A> REPL with the `neovim` package, where <A HREF="api.html#API">API</A>
<A HREF="eval.html#functions">functions</A> can be called interactively:

<B>    &gt;&gt;&gt; from neovim import attach</B>
<B>    &gt;&gt;&gt; nvim = attach('socket', path='[address]')</B>
<B>    &gt;&gt;&gt; nvim.command('echo "hello world!"')</B>
 
You can also embed an Nvim instance via |<A HREF="eval.html#jobstart()">jobstart()</A>|, and communicate using
|<A HREF="eval.html#rpcrequest()">rpcrequest()</A>| and |<A HREF="eval.html#rpcnotify()">rpcnotify()</A>|:

<B>    let nvim = jobstart(['nvim', '--embed'], {'rpc': v:true})</B>
<B>    echo rpcrequest(nvim, 'nvim_eval', '"Hello " . "world!"')</B>
<B>    call jobstop(nvim)</B>
 
==============================================================================

4. Implementing <A HREF="api.html#API">API</A> clients			*<A NAME="rpc-api-client"></A><B>rpc-api-client</B>* *<A NAME="api-client"></A><B>api-client</B>*

&quot;<A HREF="api.html#API">API</A> clients&quot; wrap the Nvim <A HREF="api.html#API">API</A> to provide idiomatic &quot;SDKs&quot; for their
respective platforms (see |<A HREF="develop.html#dev-jargon">dev-jargon</A>|). You can build a new <A HREF="api.html#API">API</A> client for
your favorite platform or programming language.

Existing <A HREF="api.html#API">API</A> clients are listed here:
    https://github.com/neovim/neovim/wiki/Related-projects#api-clients

The <A HREF="if_pyth.html#Python">Python</A> client is the reference implementation for <A HREF="api.html#API">API</A> clients. It is
always up-to-date with the Nvim <A HREF="api.html#API">API</A>, so its source code and test suite are
authoritative references.
    https://github.com/neovim/python-client

<B><FONT color="#54A23D">API client implementation guidelines </FONT></B>

  - Separate the transport layer from the rest of the library. See
    |<A HREF="#rpc-connecting">rpc-connecting</A>| for details on how clients can connect to Nvim.
  - Use a MessagePack library that implements at least version 5 of the
    MessagePack spec, which supports the `bin` and `ext` types used by Nvim.
  - Read <A HREF="api.html#API">API</A> metadata in order to create client-side wrappers for all
    <A HREF="#msgpack-rpc">msgpack-rpc</A> methods.
  - Use a single-threaded event loop library/pattern.
  - Use a fiber/coroutine library for the language being used for implementing
    a client. These greatly simplify concurrency and allow the library to
    expose a blocking <A HREF="api.html#API">API</A> on top of a non-blocking event loop without the
    complexity that comes with preemptive multitasking.
  - Don't assume anything about the order that responses to <A HREF="#msgpack-rpc">msgpack-rpc</A>
    requests will arrive.
  - Clients should expect <A HREF="#msgpack-rpc">msgpack-rpc</A> requests, which need to be handled
    immediately because Nvim is blocked while waiting for the client response.
  - Clients should expect to receive <A HREF="#msgpack-rpc">msgpack-rpc</A> notifications, but these
    don't need to be handled immediately because they won't block Nvim
    (although they should probably be handled immediately anyway).

Note: Most of the complexity could be handled by a <A HREF="#msgpack-rpc">msgpack-rpc</A> library that
supports server to client requests and notifications, but it's not clear if
this is part of the <A HREF="#msgpack-rpc">msgpack-rpc</A> spec. At least the <A HREF="if_ruby.html#Ruby">Ruby</A> <A HREF="#msgpack-rpc">msgpack-rpc</A> library
does not seem to support <A HREF="motion.html#it">it</A>:
https://github.com/msgpack-rpc/msgpack-rpc-ruby/blob/master/lib/msgpack/rpc/transport/tcp.rb#L150-L158

<B><FONT color="#54A23D">API metadata object </FONT></B>

<A HREF="api.html#API">API</A> clients exist to hide <A HREF="#msgpack-rpc">msgpack-rpc</A> details. The <A HREF="api.html#API">API</A> metadata object
contains information that makes this task easier (see also |<A HREF="#rpc-types">rpc-types</A>|):

  - The &quot;version&quot; key contains the Nvim version, <A HREF="api.html#API">API</A> level, and <A HREF="api.html#API">API</A>
    backwards-compatibility level.
  - The &quot;<A HREF="eval.html#functions">functions</A>&quot; key contains a <A HREF="eval.html#list">list</A> of metadata <A HREF="vimindex.html#objects">objects</A> for individual
    <A HREF="eval.html#functions">functions</A>.
  - Each function metadata object has |<A HREF="#rpc-types">rpc-types</A>| information about the return
    value and parameters. These can be used for generating strongly-typed APIs
    in static languages.
  - Container types may be decorated with type/size constraints, e.g.
    ArrayOf(Buffer) or ArrayOf(Integer, 2). This can be useful to generate
    even more strongly-typed APIs.
  - Functions that are considered to be methods that operate on instances of
    Nvim special types (msgpack EXT) will have the `&quot;method&quot;` attribute set to
    `true`. The receiver type is the type of the first argument. The method
    names are prefixed with `nvim_` plus a shortened type name, e.g.
    `nvim_buf_get_lines` represents the `get_lines` method of a Buffer instance.
    - Global <A HREF="eval.html#functions">functions</A> have `&quot;method&quot;` set to `false` and are prefixed with just
    `nvim_`, e.g. `nvim_get_buffers`.

So for an object-oriented language, an <A HREF="api.html#API">API</A> client contains the classes
representing Nvim special types, and the methods of each class could be
defined by stripping the prefix for the type <A HREF="motion.html#as">as</A> defined in the `types` metadata
(this will always be the first two &quot;_&quot;-separated parts of the function name).
There could also be a singleton Vim class with methods where the `nvim_`
prefix is stripped off.

==============================================================================

5. Types							    *<A NAME="rpc-types"></A><B>rpc-types</B>*

The Nvim C <A HREF="api.html#API">API</A> uses custom types for all <A HREF="eval.html#functions">functions</A>. |<A HREF="api.html#api-types">api-types</A>|
At the <A HREF="#RPC">RPC</A> layer, the types can be split into two groups:

  - Basic types that map natively to msgpack (and probably have a default
    representation in msgpack-supported programming languages)
  - Special Nvim types that map to msgpack EXT with custom type codes.

<B><FONT color="#54A23D">Basic types </FONT></B>

  Nil                               -&gt; msgpack nil
  Boolean                           -&gt; msgpack <A HREF="options.html#boolean">boolean</A>
  Integer (signed 64-bit integer)   -&gt; msgpack integer
  <A HREF="eval.html#Float">Float</A> (IEEE 754 double precision) -&gt; msgpack float
  <A HREF="eval.html#String">String</A>                            -&gt; msgpack <A HREF="eval.html#string">string</A>
  Array                             -&gt; msgpack array
  <A HREF="eval.html#Dictionary">Dictionary</A>                        -&gt; msgpack map

<B><FONT color="#54A23D">Special types (msgpack EXT) </FONT></B>

  Buffer                            -&gt; enum value kObjectTypeBuffer
  Window                            -&gt; enum value kObjectTypeWindow
  Tabpage                           -&gt; enum value kObjectTypeTabpage

<A HREF="api.html#API">API</A> <A HREF="eval.html#functions">functions</A> expecting one of the special EXT types may be passed an integer
instead, but not another EXT type. E.g. Buffer may be passed <A HREF="motion.html#as">as</A> an integer but
not <A HREF="motion.html#as">as</A> a Window or Tabpage. The EXT object data is the object id encoded <A HREF="motion.html#as">as</A>
a msgpack integer: For <A HREF="windows.html#buffers">buffers</A> this is the |<A HREF="eval.html#bufnr()">bufnr()</A>| and for <A HREF="windows.html#windows">windows</A> the
|<A HREF="windows.html#window-ID">window-ID</A>|. For tabpages the id is an internal handle, not the <A HREF="tabpage.html#tabpage">tabpage</A>
number.

To determine the type codes of the special EXT types, inspect the `types` key
of the |<A HREF="api.html#api-metadata">api-metadata</A>| at runtime. Example JSON representation:

<B>  "types": {</B>
<B>    "Buffer": {</B>
<B>      "id": 0,</B>
<B>      "prefix": "nvim_buf_"</B>
<B>    },</B>
<B>    "Window": {</B>
<B>      "id": 1,</B>
<B>      "prefix": "nvim_win_"</B>
<B>    },</B>
<B>    "Tabpage": {</B>
<B>      "id": 2,</B>
<B>      "prefix": "nvim_tabpage_"</B>
<B>    }</B>
<B>  }</B>

Even for statically compiled clients <A HREF="motion.html#it">it</A> is good practice to avoid hardcoding
the type codes, because a client may be built against one Nvim version but
connect to another with different type codes.

<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
    </div>
  </body>
</html>
