<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta content="width=device-width, initial-scale=1" name="viewport">
  </head>
  <body>
                <img src="images/logo@2x.png" id="navbar-logo" alt="Neovim">

    <div class="container">
      <h1>Vim documentation: map</h1>
<A NAME="top"></A>
<A HREF="index.html">main help file</A>

<HR>
<PRE>
*<A NAME="map.txt"></A><B>map.txt</B>*       Nvim


		  VIM REFERENCE MANUAL    by <A HREF="intro.html#Bram">Bram</A> <A HREF="intro.html#Moolenaar">Moolenaar</A>


Key <A HREF="#mapping">mapping</A>, <A HREF="#abbreviations">abbreviations</A> and user-defined commands.

This subject is introduced in sections |<A HREF="usr_05.html#05.3">05.3</A>|, |<A HREF="usr_24.html#24.7">24.7</A>| and |<A HREF="usr_40.html#40.1">40.1</A>| of the user
manual.

                                      Type |<A HREF="various.html#gO">gO</A>| to see the table of contents.

==============================================================================

1. Key <A HREF="#mapping">mapping</A>				*<A NAME="key-mapping"></A><B>key-mapping</B>* *<A NAME="mapping"></A><B>mapping</B>* *<A NAME="macro"></A><B>macro</B>*

Key <A HREF="#mapping">mapping</A> is used to change the meaning of typed keys.  The most common use
is to define a sequence of commands for a function key.  Example:

<B>	:map &lt;F2&gt; a&lt;C-R&gt;=strftime("%c")&lt;CR&gt;&lt;Esc&gt;</B>

This appends the current date and time after the cursor (in &lt;&gt; <A HREF="intro.html#notation">notation</A> |<A HREF="intro.html#&lt;&gt;">&lt;&gt;</A>|).



1.1 MAP COMMANDS					*<A NAME=":map-commands"></A><B>:map-commands</B>*

There are commands to enter new mappings, remove mappings and <A HREF="eval.html#list">list</A> mappings.
See |<A HREF="#map-overview">map-overview</A>| for the various forms of &quot;map&quot; and their relationships with
modes.


<A HREF="#{lhs}">{lhs}</A>	means left-hand-side	*<A NAME="{lhs}"></A><B>{lhs}</B>*

<A HREF="#{rhs}">{rhs}</A>	means right-hand-side	*<A NAME="{rhs}"></A><B>{rhs}</B>*


<A HREF="#:map">:map</A>	<A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-nvo">mapmode-nvo</A>|		*<A NAME=":map"></A><B>:map</B>*

:nm[ap]	<A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-n">mapmode-n</A>|		*<A NAME=":nm"></A><B>:nm</B>* *<A NAME=":nmap"></A><B>:nmap</B>*

:vm[ap]	<A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-v">mapmode-v</A>|		*<A NAME=":vm"></A><B>:vm</B>* *<A NAME=":vmap"></A><B>:vmap</B>*

:xm[ap]	<A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-x">mapmode-x</A>|		*<A NAME=":xm"></A><B>:xm</B>* *<A NAME=":xmap"></A><B>:xmap</B>*

<A HREF="#:smap">:smap</A>	<A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-s">mapmode-s</A>|		    *<A NAME=":smap"></A><B>:smap</B>*

:om[ap]	<A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-o">mapmode-o</A>|		*<A NAME=":om"></A><B>:om</B>* *<A NAME=":omap"></A><B>:omap</B>*

<A HREF="#:map!">:map!</A>	<A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-ic">mapmode-ic</A>|		*<A NAME=":map!"></A><B>:map!</B>*

:im[ap]	<A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-i">mapmode-i</A>|		*<A NAME=":im"></A><B>:im</B>* *<A NAME=":imap"></A><B>:imap</B>*

:lm[ap]	<A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-l">mapmode-l</A>|		*<A NAME=":lm"></A><B>:lm</B>* *<A NAME=":lmap"></A><B>:lmap</B>*

:cm[ap]	<A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-c">mapmode-c</A>|		*<A NAME=":cm"></A><B>:cm</B>* *<A NAME=":cmap"></A><B>:cmap</B>*

:tma[p]	<A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-t">mapmode-t</A>|		*<A NAME=":tma"></A><B>:tma</B>* *<A NAME=":tmap"></A><B>:tmap</B>*
			Map the key sequence <A HREF="#{lhs}">{lhs}</A> to <A HREF="#{rhs}">{rhs}</A> for the modes
			where the map command applies.  The result, including
			<A HREF="#{rhs}">{rhs}</A>, is then further scanned for mappings.  This
			allows for nested and recursive use of mappings.


						*<A NAME=":nore"></A><B>:nore</B>* *<A NAME=":norem"></A><B>:norem</B>*

:no[remap]  <A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-nvo">mapmode-nvo</A>|	*<A NAME=":no"></A><B>:no</B>*  *<A NAME=":noremap"></A><B>:noremap</B>* *<A NAME=":nor"></A><B>:nor</B>*

:nn[oremap] <A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-n">mapmode-n</A>|	*<A NAME=":nn"></A><B>:nn</B>*  *<A NAME=":nnoremap"></A><B>:nnoremap</B>*

:vn[oremap] <A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-v">mapmode-v</A>|	*<A NAME=":vn"></A><B>:vn</B>*  *<A NAME=":vnoremap"></A><B>:vnoremap</B>*

:xn[oremap] <A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-x">mapmode-x</A>|	*<A NAME=":xn"></A><B>:xn</B>*  *<A NAME=":xnoremap"></A><B>:xnoremap</B>*

:snor[emap] <A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-s">mapmode-s</A>|	*<A NAME=":snor"></A><B>:snor</B>* *<A NAME=":snoremap"></A><B>:snoremap</B>*

:ono[remap] <A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-o">mapmode-o</A>|	*<A NAME=":ono"></A><B>:ono</B>* *<A NAME=":onoremap"></A><B>:onoremap</B>*

:no[remap]! <A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-ic">mapmode-ic</A>|	*<A NAME=":no!"></A><B>:no!</B>* *<A NAME=":noremap!"></A><B>:noremap!</B>*

:ino[remap] <A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-i">mapmode-i</A>|	*<A NAME=":ino"></A><B>:ino</B>* *<A NAME=":inoremap"></A><B>:inoremap</B>*

:ln[oremap] <A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-l">mapmode-l</A>|	*<A NAME=":ln"></A><B>:ln</B>*  *<A NAME=":lnoremap"></A><B>:lnoremap</B>*

:cno[remap] <A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-c">mapmode-c</A>|	*<A NAME=":cno"></A><B>:cno</B>* *<A NAME=":cnoremap"></A><B>:cnoremap</B>*

:tno[remap] <A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>		|<A HREF="#mapmode-t">mapmode-t</A>|	*<A NAME=":tno"></A><B>:tno</B>* *<A NAME=":tnoremap"></A><B>:tnoremap</B>*
			Map the key sequence <A HREF="#{lhs}">{lhs}</A> to <A HREF="#{rhs}">{rhs}</A> for the modes
			where the map command applies.  Disallow <A HREF="#mapping">mapping</A> of
			<A HREF="#{rhs}">{rhs}</A>, to avoid nested and recursive mappings.  Often
			used to redefine a command.



:unm[ap]  <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-nvo">mapmode-nvo</A>|		*<A NAME=":unm"></A><B>:unm</B>*  *<A NAME=":unmap"></A><B>:unmap</B>*

:nun[map] <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-n">mapmode-n</A>|		*<A NAME=":nun"></A><B>:nun</B>*  *<A NAME=":nunmap"></A><B>:nunmap</B>*

:vu[nmap] <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-v">mapmode-v</A>|		*<A NAME=":vu"></A><B>:vu</B>*   *<A NAME=":vunmap"></A><B>:vunmap</B>*

:xu[nmap] <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-x">mapmode-x</A>|		*<A NAME=":xu"></A><B>:xu</B>*   *<A NAME=":xunmap"></A><B>:xunmap</B>*

:sunm[ap] <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-s">mapmode-s</A>|		*<A NAME=":sunm"></A><B>:sunm</B>* *<A NAME=":sunmap"></A><B>:sunmap</B>*

:ou[nmap] <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-o">mapmode-o</A>|		*<A NAME=":ou"></A><B>:ou</B>*   *<A NAME=":ounmap"></A><B>:ounmap</B>*

:unm[ap]! <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-ic">mapmode-ic</A>|		*<A NAME=":unm!"></A><B>:unm!</B>* *<A NAME=":unmap!"></A><B>:unmap!</B>*

:iu[nmap] <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-i">mapmode-i</A>|		*<A NAME=":iu"></A><B>:iu</B>*   *<A NAME=":iunmap"></A><B>:iunmap</B>*

:lu[nmap] <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-l">mapmode-l</A>|		*<A NAME=":lu"></A><B>:lu</B>*   *<A NAME=":lunmap"></A><B>:lunmap</B>*

:cu[nmap] <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-c">mapmode-c</A>|		*<A NAME=":cu"></A><B>:cu</B>*   *<A NAME=":cunmap"></A><B>:cunmap</B>*

:tunma[p] <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-t">mapmode-t</A>|		*<A NAME=":tunma"></A><B>:tunma</B>* *<A NAME=":tunmap"></A><B>:tunmap</B>*
			Remove the <A HREF="#mapping">mapping</A> of <A HREF="#{lhs}">{lhs}</A> for the modes where the
			map command applies.  The <A HREF="#mapping">mapping</A> may remain defined
			for other modes where <A HREF="motion.html#it">it</A> applies.
			Note: Trailing spaces are included in the <A HREF="#{lhs}">{lhs}</A>.  This
			unmap does NOT work:
<B>				:map @@ foo</B>
<B>				:unmap @@ | print</B>


:mapc[lear]			|<A HREF="#mapmode-nvo">mapmode-nvo</A>|		*<A NAME=":mapc"></A><B>:mapc</B>*   *<A NAME=":mapclear"></A><B>:mapclear</B>*

:nmapc[lear]			|<A HREF="#mapmode-n">mapmode-n</A>|		*<A NAME=":nmapc"></A><B>:nmapc</B>*  *<A NAME=":nmapclear"></A><B>:nmapclear</B>*

:vmapc[lear]			|<A HREF="#mapmode-v">mapmode-v</A>|		*<A NAME=":vmapc"></A><B>:vmapc</B>*  *<A NAME=":vmapclear"></A><B>:vmapclear</B>*

:xmapc[lear]			|<A HREF="#mapmode-x">mapmode-x</A>|		*<A NAME=":xmapc"></A><B>:xmapc</B>*  *<A NAME=":xmapclear"></A><B>:xmapclear</B>*

:smapc[lear]			|<A HREF="#mapmode-s">mapmode-s</A>|		*<A NAME=":smapc"></A><B>:smapc</B>*  *<A NAME=":smapclear"></A><B>:smapclear</B>*

:omapc[lear]			|<A HREF="#mapmode-o">mapmode-o</A>|		*<A NAME=":omapc"></A><B>:omapc</B>*  *<A NAME=":omapclear"></A><B>:omapclear</B>*

:mapc[lear]!			|<A HREF="#mapmode-ic">mapmode-ic</A>|		*<A NAME=":mapc!"></A><B>:mapc!</B>*  *<A NAME=":mapclear!"></A><B>:mapclear!</B>*

:imapc[lear]			|<A HREF="#mapmode-i">mapmode-i</A>|		*<A NAME=":imapc"></A><B>:imapc</B>*  *<A NAME=":imapclear"></A><B>:imapclear</B>*

:lmapc[lear]			|<A HREF="#mapmode-l">mapmode-l</A>|		*<A NAME=":lmapc"></A><B>:lmapc</B>*  *<A NAME=":lmapclear"></A><B>:lmapclear</B>*

:cmapc[lear]			|<A HREF="#mapmode-c">mapmode-c</A>|		*<A NAME=":cmapc"></A><B>:cmapc</B>*  *<A NAME=":cmapclear"></A><B>:cmapclear</B>*

:tmapc[lear]			|<A HREF="#mapmode-t">mapmode-t</A>|		*<A NAME=":tmapc"></A><B>:tmapc</B>*  *<A NAME=":tmapclear"></A><B>:tmapclear</B>*
			Remove ALL mappings for the modes where the map
			command applies.
			Use the &lt;buffer&gt; argument to remove buffer-local
			mappings |<A HREF="#:map-&lt;buffer&gt;">:map-&lt;buffer&gt;</A>|
			Warning: This also removes the default mappings.

<A HREF="#:map">:map</A>				|<A HREF="#mapmode-nvo">mapmode-nvo</A>|
:nm[ap]				|<A HREF="#mapmode-n">mapmode-n</A>|
:vm[ap]				|<A HREF="#mapmode-v">mapmode-v</A>|
:xm[ap]				|<A HREF="#mapmode-x">mapmode-x</A>|
:sm[ap]				|<A HREF="#mapmode-s">mapmode-s</A>|
:om[ap]				|<A HREF="#mapmode-o">mapmode-o</A>|
<A HREF="#:map!">:map!</A>				|<A HREF="#mapmode-ic">mapmode-ic</A>|
:im[ap]				|<A HREF="#mapmode-i">mapmode-i</A>|
:lm[ap]				|<A HREF="#mapmode-l">mapmode-l</A>|
:cm[ap]				|<A HREF="#mapmode-c">mapmode-c</A>|
:tma[p]				|<A HREF="#mapmode-t">mapmode-t</A>|
			<A HREF="eval.html#List">List</A> all key mappings for the modes where the map
			command applies.  Note that &quot;<A HREF="#:map">:map</A>&quot; and &quot;<A HREF="#:map!">:map!</A>&quot; are
			used most often, because they include the other modes.


<A HREF="#:map">:map</A>    <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-nvo">mapmode-nvo</A>|		*<A NAME=":map_l"></A><B>:map_l</B>*

:nm[ap] <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-n">mapmode-n</A>|		*<A NAME=":nmap_l"></A><B>:nmap_l</B>*

:vm[ap] <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-v">mapmode-v</A>|		*<A NAME=":vmap_l"></A><B>:vmap_l</B>*

:xm[ap] <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-x">mapmode-x</A>|		*<A NAME=":xmap_l"></A><B>:xmap_l</B>*

:sm[ap] <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-s">mapmode-s</A>|		*<A NAME=":smap_l"></A><B>:smap_l</B>*

:om[ap] <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-o">mapmode-o</A>|		*<A NAME=":omap_l"></A><B>:omap_l</B>*

<A HREF="#:map!">:map!</A>   <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-ic">mapmode-ic</A>|		*<A NAME=":map_l!"></A><B>:map_l!</B>*

:im[ap] <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-i">mapmode-i</A>|		*<A NAME=":imap_l"></A><B>:imap_l</B>*

:lm[ap] <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-l">mapmode-l</A>|		*<A NAME=":lmap_l"></A><B>:lmap_l</B>*

:cm[ap] <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-c">mapmode-c</A>|		*<A NAME=":cmap_l"></A><B>:cmap_l</B>*

:tma[p] <A HREF="#{lhs}">{lhs}</A>			|<A HREF="#mapmode-t">mapmode-t</A>|		*<A NAME=":tmap_l"></A><B>:tmap_l</B>*
			<A HREF="eval.html#List">List</A> the key mappings for the key sequences starting
			with <A HREF="#{lhs}">{lhs}</A> in the modes where the map command applies.

These commands are used to map a key or key sequence to a <A HREF="eval.html#string">string</A> of
characters.  You can use this to put command sequences under function keys,
translate one key into another, etc.  See |<A HREF="starting.html#:mkexrc">:mkexrc</A>| for how to save and
restore the current mappings.


							*<A NAME="map-ambiguous"></A><B>map-ambiguous</B>*
When two mappings start with the same sequence of characters, they are
ambiguous.  Example:
<B>	:imap aa foo</B>
<B>	:imap aaa bar</B>
When Vim has read &quot;aa&quot;, <A HREF="motion.html#it">it</A> will need to get another character to be able to
decide if &quot;aa&quot; or &quot;aaa&quot; should be mapped.  This means that after typing &quot;aa&quot;
that <A HREF="#mapping">mapping</A> won't get expanded yet, Vim is waiting for another character.
If you type a space, then &quot;foo&quot; will get inserted, plus the space.  If you
type &quot;<A HREF="insert.html#a">a</A>&quot;, then &quot;<A HREF="motion.html#bar">bar</A>&quot; will get inserted.



1.2 SPECIAL ARGUMENTS					*<A NAME=":map-arguments"></A><B>:map-arguments</B>*

&quot;&lt;buffer&gt;&quot;, &quot;&lt;nowait&gt;&quot;, &quot;&lt;silent&gt;&quot;, &quot;&lt;script&gt;&quot;, &quot;&lt;expr&gt;&quot; and
&quot;&lt;unique&gt;&quot; can be used in any order.  They must appear right after the
command, before any other arguments.


				*<A NAME=":map-local"></A><B>:map-local</B>* *<A NAME=":map-&lt;buffer&gt;"></A><B>:map-&lt;buffer&gt;</B>* *<A NAME="E224"></A><B>E224</B>* *<A NAME="E225"></A><B>E225</B>*
If the first argument to one of these commands is &quot;&lt;buffer&gt;&quot; the <A HREF="#mapping">mapping</A> will
be effective in the current buffer only.  Example:
<B>	:map &lt;buffer&gt;  ,w  /[.,;]&lt;CR&gt;</B>
Then you can map &quot;,w&quot; to something else in another buffer:
<B>	:map &lt;buffer&gt;  ,w  /[#&amp;!]&lt;CR&gt;</B>
The local buffer mappings are used before the global ones.  See &lt;nowait&gt; below
to make a short local <A HREF="#mapping">mapping</A> not taking effect when a longer global one
exists.
The &quot;&lt;buffer&gt;&quot; argument can also be used to clear mappings:
<B>	:unmap &lt;buffer&gt; ,w</B>
<B>	:mapclear &lt;buffer&gt;</B>
Local mappings are also cleared when a buffer is deleted, but not when <A HREF="motion.html#it">it</A> is
unloaded.  Just like local option values.
Also see |<A HREF="#map-precedence">map-precedence</A>|.


						*<A NAME=":map-&lt;nowait&gt;"></A><B>:map-&lt;nowait&gt;</B>* *<A NAME=":map-nowait"></A><B>:map-nowait</B>*
When defining a buffer-local <A HREF="#mapping">mapping</A> for &quot;<A HREF="motion.html#,">,</A>&quot; there may be a global <A HREF="#mapping">mapping</A>
that starts with &quot;<A HREF="motion.html#,">,</A>&quot;.  Then you need to type another character for Vim to know
whether to use the &quot;<A HREF="motion.html#,">,</A>&quot; <A HREF="#mapping">mapping</A> or the longer one.  To avoid this add the
&lt;nowait&gt; argument.  Then the <A HREF="#mapping">mapping</A> will be used when <A HREF="motion.html#it">it</A> matches, Vim does
not wait for more characters to be typed.  However, if the characters were
already typed they are used.


						*<A NAME=":map-&lt;silent&gt;"></A><B>:map-&lt;silent&gt;</B>* *<A NAME=":map-silent"></A><B>:map-silent</B>*
To define a <A HREF="#mapping">mapping</A> which will not be echoed on the command line, add
&quot;&lt;silent&gt;&quot; <A HREF="motion.html#as">as</A> the first argument.  Example:
<B>	:map &lt;silent&gt; ,h /Header&lt;CR&gt;</B>
The search <A HREF="eval.html#string">string</A> will not be echoed when using this <A HREF="#mapping">mapping</A>.  Messages from
the executed command are still given though.  To shut them up too, add a
&quot;<A HREF="various.html#:silent">:silent</A>&quot; in the executed command:
<B>	:map &lt;silent&gt; ,h :exe ":silent normal /Header\r"&lt;CR&gt;</B>
Prompts will still be given, e.g., for <A HREF="eval.html#inputdialog()">inputdialog()</A>.
Using &quot;&lt;silent&gt;&quot; for an abbreviation is possible, but will cause redrawing of
the command line to fail.


						*<A NAME=":map-&lt;script&gt;"></A><B>:map-&lt;script&gt;</B>* *<A NAME=":map-script"></A><B>:map-script</B>*
If the first argument to one of these commands is &quot;&lt;script&gt;&quot; and <A HREF="motion.html#it">it</A> is used to
define a new <A HREF="#mapping">mapping</A> or abbreviation, the <A HREF="#mapping">mapping</A> will only remap characters
in the <A HREF="#{rhs}">{rhs}</A> using mappings that were defined local to a <A HREF="usr_41.html#script">script</A>, starting with
&quot;<A HREF="#&lt;SID&gt;">&lt;SID&gt;</A>&quot;.  This can be used to avoid that mappings from outside a <A HREF="usr_41.html#script">script</A>
interfere (e.g., when <A HREF="visual.html#CTRL-V">CTRL-V</A> is remapped in mswin.vim), but <A HREF="diff.html#do">do</A> use other
mappings defined in the <A HREF="usr_41.html#script">script</A>.
Note: &quot;<A HREF="#:map">:map</A> &lt;script&gt;&quot; and &quot;<A HREF="#:noremap">:noremap</A> &lt;script&gt;&quot; <A HREF="diff.html#do">do</A> the same thing.  The
&quot;&lt;script&gt;&quot; overrules the command name.  Using &quot;<A HREF="#:noremap">:noremap</A> &lt;script&gt;&quot; is
preferred, because it's clearer that remapping is (mostly) disabled.


						*<A NAME=":map-&lt;unique&gt;"></A><B>:map-&lt;unique&gt;</B>* *<A NAME="E226"></A><B>E226</B>* *<A NAME="E227"></A><B>E227</B>*
If the first argument to one of these commands is &quot;&lt;unique&gt;&quot; and <A HREF="motion.html#it">it</A> is used to
define a new <A HREF="#mapping">mapping</A> or abbreviation, the command will fail if the <A HREF="#mapping">mapping</A> or
abbreviation already exists.  Example:
<B>	:map &lt;unique&gt; ,w  /[#&amp;!]&lt;CR&gt;</B>
When defining a local <A HREF="#mapping">mapping</A>, there will also be a check if a global map
already exists which is equal.
Example of what will fail:
<B>	:map ,w  /[#&amp;!]&lt;CR&gt;</B>
<B>	:map &lt;buffer&gt; &lt;unique&gt; ,w  /[.,;]&lt;CR&gt;</B>
If you want to map a key and then have <A HREF="motion.html#it">it</A> <A HREF="diff.html#do">do</A> what <A HREF="motion.html#it">it</A> was originally mapped to,
have a look at |<A HREF="eval.html#maparg()">maparg()</A>|.


						*<A NAME=":map-&lt;expr&gt;"></A><B>:map-&lt;expr&gt;</B>* *<A NAME=":map-expression"></A><B>:map-expression</B>*
If the first argument to one of these commands is &quot;&lt;expr&gt;&quot; and <A HREF="motion.html#it">it</A> is used to
define a new <A HREF="#mapping">mapping</A> or abbreviation, the argument is an <A HREF="eval.html#expression">expression</A>.  The
<A HREF="eval.html#expression">expression</A> is evaluated to obtain the <A HREF="#{rhs}">{rhs}</A> that is used.  Example:
<B>	:inoremap &lt;expr&gt; . InsertDot()</B>
The result of the InsertDot() function will be inserted.  It could check the
text before the cursor and start omni completion when some condition is met.

For <A HREF="#abbreviations">abbreviations</A> |<A HREF="eval.html#v:char">v:char</A>| is set to the character that was typed to trigger
the abbreviation.  You can use this to decide how to expand the <A HREF="#{lhs}">{lhs}</A>.  You
should not either insert or change the <A HREF="eval.html#v:char">v:char</A>.

Be very careful about side effects!  The <A HREF="eval.html#expression">expression</A> is evaluated while
obtaining characters, you may very well make the command dysfunctional.
For this reason the following is blocked:
- Changing the buffer text |<A HREF="eval.html#textlock">textlock</A>|.
- Editing another buffer.
- The |<A HREF="various.html#:normal">:normal</A>| command.
- Moving the cursor is allowed, but <A HREF="motion.html#it">it</A> is restored afterwards.
- If the cmdline is changed, the old text and cursor position are restored.
If you want the <A HREF="#mapping">mapping</A> to <A HREF="diff.html#do">do</A> any of these let the returned characters <A HREF="diff.html#do">do</A>
that. Alternatively use a |<A HREF="#&lt;Cmd&gt;">&lt;Cmd&gt;</A>| <A HREF="#mapping">mapping</A> which doesn't have these
restrictions.

You can use <A HREF="eval.html#getchar()">getchar()</A>, <A HREF="motion.html#it">it</A> consumes typeahead if there is any. E.g., if you
have these mappings:
<B>  inoremap &lt;expr&gt; &lt;C-L&gt; nr2char(getchar())</B>
<B>  inoremap &lt;expr&gt; &lt;C-L&gt;x "foo"</B>
If you now type <A HREF="various.html#CTRL-L">CTRL-L</A> nothing happens yet, Vim needs the next character to
decide what <A HREF="#mapping">mapping</A> to use.  If you type '<A HREF="change.html#x">x</A>' the second <A HREF="#mapping">mapping</A> is used and
&quot;foo&quot; is inserted.  If you type any other key the first <A HREF="#mapping">mapping</A> is used,
<A HREF="eval.html#getchar()">getchar()</A> gets the typed key and returns <A HREF="motion.html#it">it</A>.

Here is an example that inserts a <A HREF="eval.html#list">list</A> number that increases:
<B>	let counter = 0</B>
<B>	inoremap &lt;expr&gt; &lt;C-L&gt; ListItem()</B>
<B>	inoremap &lt;expr&gt; &lt;C-R&gt; ListReset()</B>

<B>	func ListItem()</B>
<B>	  let g:counter += 1</B>
<B>	  return g:counter . '. '</B>
<B>	endfunc</B>

<B>	func ListReset()</B>
<B>	  let g:counter = 0</B>
<B>	  return ''</B>
<B>	endfunc</B>

<A HREF="various.html#CTRL-L">CTRL-L</A> inserts the next number, <A HREF="undo.html#CTRL-R">CTRL-R</A> resets the <A HREF="intro.html#count">count</A>.  <A HREF="undo.html#CTRL-R">CTRL-R</A> returns an
empty <A HREF="eval.html#string">string</A>, so that nothing is inserted.

Note that there are some tricks to make special keys work and <A HREF="intro.html#escape">escape</A> CSI bytes
in the text.  The |<A HREF="#:map">:map</A>| command also does this, thus you must avoid that <A HREF="motion.html#it">it</A>
is done <A HREF="if_cscop.html#twice">twice</A>.  This does not work:
<B>	:imap &lt;expr&gt; &lt;F3&gt; "&lt;Char-0x611B&gt;"</B>
Because the &lt;Char- sequence is escaped for being a |<A HREF="#:imap">:imap</A>| argument and then
again for using &lt;expr&gt;.  This does work:
<B>	:imap &lt;expr&gt; &lt;F3&gt; "\u611B"</B>
Using 0x80 <A HREF="motion.html#as">as</A> a single byte before other text does not work, <A HREF="motion.html#it">it</A> will be seen
<A HREF="motion.html#as">as</A> a special key.


						*<A NAME="&lt;Cmd&gt;"></A><B>&lt;Cmd&gt;</B>* *<A NAME=":map-command"></A><B>:map-command</B>*
A command <A HREF="#mapping">mapping</A> is a <A HREF="#mapping">mapping</A> that directly executes a command. Command
mappings are written by placing a command in between <A HREF="#&lt;Cmd&gt;">&lt;Cmd&gt;</A> and <A HREF="motion.html#&lt;CR&gt;">&lt;CR&gt;</A> in the
rhs of a <A HREF="#mapping">mapping</A> (in any mode):
<B>	noremap &lt;f3&gt; &lt;Cmd&gt;echo mode(1)&lt;cr&gt;</B>
 

							*<A NAME="E5520"></A><B>E5520</B>*
The command must be complete and ended with a <A HREF="motion.html#&lt;CR&gt;">&lt;CR&gt;</A>. If the command is
incomplete, an error is raised. |<A HREF="cmdline.html#Command-line">Command-line</A>| mode is never entered.

This is more flexible than using `:&lt;c-u&gt;` in visual and <A HREF="motion.html#operator">operator</A> pending
mode, or `&lt;c-o&gt;:` in insert mode, <A HREF="motion.html#as">as</A> the commands are exectued directly in the
mode, and not normal mode. Also visual mode is not aborted. Commands can be
invoked directly in cmdline mode, which is not simple otherwise (a <A HREF="eval.html#timer">timer</A> has
to be used). Unlike &lt;expr&gt; mappings, there are not any specific restrictions
what the command can <A HREF="diff.html#do">do</A>, except for what is normally possible to <A HREF="diff.html#do">do</A> in every
specific mode. The command should be executed the same way <A HREF="motion.html#as">as</A> if an
(unrestricted) |<A HREF="intro.html#autocmd">autocmd</A>| was invoked or an async event event was processed.

Note: In select mode, |<A HREF="#:map">:map</A>| or |<A HREF="#:vmap">:vmap</A>| command mappings will be executed in
visual mode. If a <A HREF="#mapping">mapping</A> is intended to work in select mode, <A HREF="motion.html#it">it</A> is
recomendend to map <A HREF="motion.html#it">it</A> using |<A HREF="#:smap">:smap</A>|, possibly in addition to the same <A HREF="#mapping">mapping</A>
with |<A HREF="#:map">:map</A>| or |<A HREF="#:xmap">:xmap</A>|.


1.3 MAPPING AND MODES					*<A NAME=":map-modes"></A><B>:map-modes</B>*

		*<A NAME="mapmode-nvo"></A><B>mapmode-nvo</B>* *<A NAME="mapmode-n"></A><B>mapmode-n</B>* *<A NAME="mapmode-v"></A><B>mapmode-v</B>* *<A NAME="mapmode-o"></A><B>mapmode-o</B>* *<A NAME="mapmode-t"></A><B>mapmode-t</B>*

There are seven sets of mappings
- For <A HREF="intro.html#Normal">Normal</A> mode: When typing commands.
- For <A HREF="visual.html#Visual">Visual</A> mode: When typing commands while the <A HREF="visual.html#Visual">Visual</A> area is highlighted.
- For <A HREF="visual.html#Select">Select</A> mode: like <A HREF="visual.html#Visual">Visual</A> mode but typing text replaces the selection.
- For <A HREF="intro.html#Operator-pending">Operator-pending</A> mode: When an <A HREF="motion.html#operator">operator</A> is pending (after &quot;<A HREF="change.html#d">d</A>&quot;, &quot;<A HREF="change.html#y">y</A>&quot;, &quot;<A HREF="change.html#c">c</A>&quot;,
  etc.).  See below: |<A HREF="#omap-info">omap-info</A>|.
- For <A HREF="insert.html#Insert">Insert</A> mode.  These are also used in <A HREF="insert.html#Replace">Replace</A> mode.
- For <A HREF="cmdline.html#Command-line">Command-line</A> mode: When entering a &quot;<A HREF="cmdline.html#:">:</A>&quot; or &quot;<A HREF="pattern.html#/">/</A>&quot; command.
- For Terminal mode: When typing in a |<A HREF="various.html#:terminal">:terminal</A>| buffer.

Special <A HREF="change.html#case">case</A>: While typing a <A HREF="intro.html#count">count</A> for a command in <A HREF="intro.html#Normal">Normal</A> mode, <A HREF="#mapping">mapping</A> zero
is disabled.  This makes <A HREF="motion.html#it">it</A> possible to map zero without making <A HREF="motion.html#it">it</A> impossible
to type a <A HREF="intro.html#count">count</A> with a zero.


						*<A NAME="map-overview"></A><B>map-overview</B>* *<A NAME="map-modes"></A><B>map-modes</B>*
Overview of which map command works in which mode.  More details below.
<B><FONT color="#54A23D">     COMMANDS                    MODES </FONT></B>
<A HREF="#:map">:map</A>   <A HREF="#:noremap">:noremap</A>  <A HREF="#:unmap">:unmap</A>     <A HREF="intro.html#Normal">Normal</A>, <A HREF="visual.html#Visual">Visual</A>, <A HREF="visual.html#Select">Select</A>, <A HREF="intro.html#Operator-pending">Operator-pending</A>
<A HREF="#:nmap">:nmap</A>  <A HREF="#:nnoremap">:nnoremap</A> <A HREF="#:nunmap">:nunmap</A>    <A HREF="intro.html#Normal">Normal</A>
<A HREF="#:vmap">:vmap</A>  <A HREF="#:vnoremap">:vnoremap</A> <A HREF="#:vunmap">:vunmap</A>    <A HREF="visual.html#Visual">Visual</A> and <A HREF="visual.html#Select">Select</A>
<A HREF="#:smap">:smap</A>  <A HREF="#:snoremap">:snoremap</A> <A HREF="#:sunmap">:sunmap</A>    <A HREF="visual.html#Select">Select</A>
<A HREF="#:xmap">:xmap</A>  <A HREF="#:xnoremap">:xnoremap</A> <A HREF="#:xunmap">:xunmap</A>    <A HREF="visual.html#Visual">Visual</A>
<A HREF="#:omap">:omap</A>  <A HREF="#:onoremap">:onoremap</A> <A HREF="#:ounmap">:ounmap</A>    <A HREF="intro.html#Operator-pending">Operator-pending</A>
<A HREF="#:map!">:map!</A>  <A HREF="#:noremap!">:noremap!</A> <A HREF="#:unmap!">:unmap!</A>    <A HREF="insert.html#Insert">Insert</A> and <A HREF="cmdline.html#Command-line">Command-line</A>
<A HREF="#:imap">:imap</A>  <A HREF="#:inoremap">:inoremap</A> <A HREF="#:iunmap">:iunmap</A>    <A HREF="insert.html#Insert">Insert</A>
<A HREF="#:lmap">:lmap</A>  <A HREF="#:lnoremap">:lnoremap</A> <A HREF="#:lunmap">:lunmap</A>    <A HREF="insert.html#Insert">Insert</A>, <A HREF="cmdline.html#Command-line">Command-line</A>, Lang-Arg
<A HREF="#:cmap">:cmap</A>  <A HREF="#:cnoremap">:cnoremap</A> <A HREF="#:cunmap">:cunmap</A>    <A HREF="cmdline.html#Command-line">Command-line</A>
<A HREF="#:tmap">:tmap</A>  <A HREF="#:tnoremap">:tnoremap</A> <A HREF="#:tunmap">:tunmap</A>    Terminal


<B><FONT color="#54A23D">    COMMANDS				      MODES </FONT></B>
<B><FONT color="#54A23D">				       Normal  Visual+Select  Operator-pending </FONT></B>
<A HREF="#:map">:map</A>   <A HREF="#:noremap">:noremap</A>   <A HREF="#:unmap">:unmap</A>   <A HREF="#:mapclear">:mapclear</A>	 yes	    yes		   yes
<A HREF="#:nmap">:nmap</A>  <A HREF="#:nnoremap">:nnoremap</A>  <A HREF="#:nunmap">:nunmap</A>  <A HREF="#:nmapclear">:nmapclear</A>	 yes	     -		    -
<A HREF="#:vmap">:vmap</A>  <A HREF="#:vnoremap">:vnoremap</A>  <A HREF="#:vunmap">:vunmap</A>  <A HREF="#:vmapclear">:vmapclear</A>	  -	    yes		    -
<A HREF="#:omap">:omap</A>  <A HREF="#:onoremap">:onoremap</A>  <A HREF="#:ounmap">:ounmap</A>  <A HREF="#:omapclear">:omapclear</A>	  -	     -		   yes

<A HREF="#:nunmap">:nunmap</A> can also be used outside of a monastery.

						*<A NAME="mapmode-x"></A><B>mapmode-x</B>* *<A NAME="mapmode-s"></A><B>mapmode-s</B>*
Some commands work both in <A HREF="visual.html#Visual">Visual</A> and <A HREF="visual.html#Select">Select</A> mode, some in only one.  Note
that quite often &quot;<A HREF="visual.html#Visual">Visual</A>&quot; is mentioned where both <A HREF="visual.html#Visual">Visual</A> and <A HREF="visual.html#Select">Select</A> mode
apply. |<A HREF="visual.html#Select-mode-mapping">Select-mode-mapping</A>|
NOTE: Mapping a printable character in <A HREF="visual.html#Select">Select</A> mode may confuse the user.  It's
better to explicitly use <A HREF="#:xmap">:xmap</A> and <A HREF="#:smap">:smap</A> for printable characters.  Or use
<A HREF="#:sunmap">:sunmap</A> after defining the <A HREF="#mapping">mapping</A>.

<B><FONT color="#54A23D">    COMMANDS				      MODES </FONT></B>
<B><FONT color="#54A23D">					  Visual    Select </FONT></B>
<A HREF="#:vmap">:vmap</A>  <A HREF="#:vnoremap">:vnoremap</A>  <A HREF="#:vunmap">:vunmap</A>  <A HREF="#:vmapclear">:vmapclear</A>	    yes      yes
<A HREF="#:xmap">:xmap</A>  <A HREF="#:xnoremap">:xnoremap</A>  <A HREF="#:xunmap">:xunmap</A>  <A HREF="#:xmapclear">:xmapclear</A>	    yes       -
<A HREF="#:smap">:smap</A>  <A HREF="#:snoremap">:snoremap</A>  <A HREF="#:sunmap">:sunmap</A>  <A HREF="#:smapclear">:smapclear</A>	    -	     yes


			*<A NAME="mapmode-ic"></A><B>mapmode-ic</B>* *<A NAME="mapmode-i"></A><B>mapmode-i</B>* *<A NAME="mapmode-c"></A><B>mapmode-c</B>* *<A NAME="mapmode-l"></A><B>mapmode-l</B>*
Some commands work both in <A HREF="insert.html#Insert">Insert</A> mode and <A HREF="cmdline.html#Command-line">Command-line</A> mode, some not:

<B><FONT color="#54A23D">    COMMANDS				      MODES </FONT></B>
<B><FONT color="#54A23D">					  Insert  Command-line	Lang-Arg </FONT></B>
<A HREF="#:map!">:map!</A>  <A HREF="#:noremap!">:noremap!</A>  <A HREF="#:unmap!">:unmap!</A>  <A HREF="#:mapclear!">:mapclear!</A>	    yes	       yes	   -
<A HREF="#:imap">:imap</A>  <A HREF="#:inoremap">:inoremap</A>  <A HREF="#:iunmap">:iunmap</A>  <A HREF="#:imapclear">:imapclear</A>	    yes		-	   -
<A HREF="#:cmap">:cmap</A>  <A HREF="#:cnoremap">:cnoremap</A>  <A HREF="#:cunmap">:cunmap</A>  <A HREF="#:cmapclear">:cmapclear</A>	     -	       yes	   -
<A HREF="#:lmap">:lmap</A>  <A HREF="#:lnoremap">:lnoremap</A>  <A HREF="#:lunmap">:lunmap</A>  <A HREF="#:lmapclear">:lmapclear</A>	    yes*       yes*	  yes*

The original <A HREF="intro.html#Vi">Vi</A> did not have separate mappings for
Normal/Visual/Operator-pending mode and for Insert/Command-line mode.
Therefore the &quot;<A HREF="#:map">:map</A>&quot; and &quot;<A HREF="#:map!">:map!</A>&quot; commands enter and display mappings for
several modes.  In Vim you can use the &quot;<A HREF="#:nmap">:nmap</A>&quot;, &quot;<A HREF="#:vmap">:vmap</A>&quot;, &quot;<A HREF="#:omap">:omap</A>&quot;, &quot;<A HREF="#:cmap">:cmap</A>&quot; and
&quot;<A HREF="#:imap">:imap</A>&quot; commands to enter mappings for each mode separately.


							*<A NAME="omap-info"></A><B>omap-info</B>*
<A HREF="intro.html#Operator-pending">Operator-pending</A> mappings can be used to define a <A HREF="intro.html#movement">movement</A> command that can be
used with any <A HREF="motion.html#operator">operator</A>.  Simple example: &quot;<A HREF="#:omap">:omap</A> { w&quot; makes &quot;y{&quot; work like &quot;yw&quot;
and &quot;d{&quot; like &quot;dw&quot;.

To ignore the starting cursor position and select different text, you can have
the omap start <A HREF="visual.html#Visual">Visual</A> mode to select the text to be operated upon.  Example
that operates on a function name in the current line:
<B>	onoremap &lt;silent&gt; F :&lt;C-U&gt;normal! 0f(hviw&lt;CR&gt;</B>
The <A HREF="scroll.html#CTRL-U">CTRL-U</A> (&lt;C-U&gt;) is used to remove the range that Vim may insert.  The
<A HREF="intro.html#Normal">Normal</A> mode commands find the first '<A HREF="motion.html#(">(</A>' character and select the first <A HREF="motion.html#word">word</A>
before <A HREF="motion.html#it">it</A>.  That usually is the function name.

To enter a <A HREF="#mapping">mapping</A> for <A HREF="intro.html#Normal">Normal</A> and <A HREF="visual.html#Visual">Visual</A> mode, but not <A HREF="intro.html#Operator-pending">Operator-pending</A> mode,
first define <A HREF="motion.html#it">it</A> for all three modes, then unmap <A HREF="motion.html#it">it</A> for <A HREF="intro.html#Operator-pending">Operator-pending</A> mode:
	<A HREF="#:map">:map</A>    xx something-difficult
	<A HREF="#:ounmap">:ounmap</A> xx
Likewise for a <A HREF="#mapping">mapping</A> for <A HREF="visual.html#Visual">Visual</A> and <A HREF="intro.html#Operator-pending">Operator-pending</A> mode or <A HREF="intro.html#Normal">Normal</A> and
<A HREF="intro.html#Operator-pending">Operator-pending</A> mode.


						*<A NAME="language-mapping"></A><B>language-mapping</B>*
&quot;<A HREF="#:lmap">:lmap</A>&quot; defines a <A HREF="#mapping">mapping</A> that applies to:
- <A HREF="insert.html#Insert">Insert</A> mode
- <A HREF="cmdline.html#Command-line">Command-line</A> mode
- when entering a search <A HREF="pattern.html#pattern">pattern</A>
- the argument of the commands that accept a text character, such <A HREF="motion.html#as">as</A> &quot;<A HREF="change.html#r">r</A>&quot; and
  &quot;<A HREF="motion.html#f">f</A>&quot;
- for the <A HREF="eval.html#input()">input()</A> line
Generally: Whenever a character is to be typed that is part of the text in the
buffer, not a Vim command character.  &quot;Lang-Arg&quot; isn't really another mode,
it's just used here for this situation.
   The simplest way to load a set of related language mappings is by using the
<A HREF="options.html#'keymap'">'keymap'</A> option.  See |<A HREF="usr_45.html#45.5">45.5</A>|.
   In <A HREF="insert.html#Insert">Insert</A> mode and in <A HREF="cmdline.html#Command-line">Command-line</A> mode the mappings can be disabled with
the CTRL-^ command |<A HREF="insert.html#i_CTRL-^">i_CTRL-^</A>| |<A HREF="cmdline.html#c_CTRL-^">c_CTRL-^</A>|. These commands change the value of
the <A HREF="options.html#'iminsert'">'iminsert'</A> option.  When starting to enter a normal command line (not a
search <A HREF="pattern.html#pattern">pattern</A>) the mappings are disabled until a <A HREF="editing.html#CTRL-^">CTRL-^</A> is typed.  The state
last used is remembered for <A HREF="insert.html#Insert">Insert</A> mode and Search patterns separately.  The
state for <A HREF="insert.html#Insert">Insert</A> mode is also used when typing a character <A HREF="motion.html#as">as</A> an argument to
command like &quot;<A HREF="motion.html#f">f</A>&quot; or &quot;<A HREF="motion.html#t">t</A>&quot;.
   Language mappings will never be applied to already mapped characters.  They
are only used for typed characters.  This assumes that the language <A HREF="#mapping">mapping</A>
was already done when typing the <A HREF="#mapping">mapping</A>.



1.4 LISTING MAPPINGS					*<A NAME="map-listing"></A><B>map-listing</B>*

When listing mappings the characters in the first two columns are:

<B><FONT color="#54A23D">      CHAR	MODE	</FONT></B>
     <A HREF="motion.html#&lt;Space&gt;">&lt;Space&gt;</A>	<A HREF="intro.html#Normal">Normal</A>, <A HREF="visual.html#Visual">Visual</A>, <A HREF="visual.html#Select">Select</A> and <A HREF="intro.html#Operator-pending">Operator-pending</A>
	<A HREF="pattern.html#n">n</A>	<A HREF="intro.html#Normal">Normal</A>
	<A HREF="visual.html#v">v</A>	<A HREF="visual.html#Visual">Visual</A> and <A HREF="visual.html#Select">Select</A>
	<A HREF="change.html#s">s</A>	<A HREF="visual.html#Select">Select</A>
	<A HREF="change.html#x">x</A>	<A HREF="visual.html#Visual">Visual</A>
	<A HREF="insert.html#o">o</A>	<A HREF="intro.html#Operator-pending">Operator-pending</A>
	!	<A HREF="insert.html#Insert">Insert</A> and <A HREF="cmdline.html#Command-line">Command-line</A>
	<A HREF="insert.html#i">i</A>	<A HREF="insert.html#Insert">Insert</A>
	<A HREF="motion.html#l">l</A>	&quot;<A HREF="#:lmap">:lmap</A>&quot; mappings for <A HREF="insert.html#Insert">Insert</A>, <A HREF="cmdline.html#Command-line">Command-line</A> and Lang-Arg
	<A HREF="change.html#c">c</A>	<A HREF="cmdline.html#Command-line">Command-line</A>

Just before the <A HREF="#{rhs}">{rhs}</A> a special character can appear:
	&#42;	indicates that <A HREF="motion.html#it">it</A> is not remappable
	<A HREF="change.html#&amp;">&amp;</A>	indicates that only <A HREF="#script-local">script-local</A> mappings are remappable
	@	indicates a buffer-local <A HREF="#mapping">mapping</A>

Everything from the first non-blank after <A HREF="#{lhs}">{lhs}</A> up to the end of the line
(or '&#124;') is considered to be part of <A HREF="#{rhs}">{rhs}</A>.  This allows the <A HREF="#{rhs}">{rhs}</A> to end
with a space.

Note: When using mappings for <A HREF="visual.html#Visual">Visual</A> mode, you can use the &quot;<A HREF="motion.html#'&lt;">'&lt;</A>&quot; <A HREF="motion.html#mark">mark</A>, which
is the start of the last selected <A HREF="visual.html#Visual">Visual</A> area in the current buffer |<A HREF="motion.html#'&lt;">'&lt;</A>|.

The |<A HREF="various.html#:filter">:filter</A>| command can be used to select what mappings to <A HREF="eval.html#list">list</A>.  The
<A HREF="pattern.html#pattern">pattern</A> is matched against the <A HREF="#{lhs}">{lhs}</A> and <A HREF="#{rhs}">{rhs}</A> in the raw form.


							*<A NAME=":map-verbose"></A><B>:map-verbose</B>*
When <A HREF="options.html#'verbose'">'verbose'</A> is non-zero, listing a key map will also display where <A HREF="motion.html#it">it</A> was
last defined.  Example:

<B>	:verbose map &lt;C-W&gt;*</B>
<B>	n  &lt;C-W&gt;*      * &lt;C-W&gt;&lt;C-S&gt;*</B>
<B>		Last set from ~/.config/nvim/init.vim</B>

See |<A HREF="various.html#:verbose-cmd">:verbose-cmd</A>| for more information.



1.5 MAPPING SPECIAL KEYS				*<A NAME=":map-special-keys"></A><B>:map-special-keys</B>*

There are two ways to map a special key:
1. The Vi-compatible method: Map the key code.  Often this is a sequence that
   starts with <A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A>.  To enter a <A HREF="#mapping">mapping</A> like this you type &quot;<A HREF="#:map">:map</A> &quot; and then
   you have to type <A HREF="visual.html#CTRL-V">CTRL-V</A> before hitting the function key.  Note that when
   the key code for the key is in the |<A HREF="term.html#terminfo">terminfo</A>| entry, <A HREF="motion.html#it">it</A> will automatically
   be translated into the internal code and become the second way of <A HREF="#mapping">mapping</A>.
2. The second method is to use the internal code for the function key.  To
   enter such a <A HREF="#mapping">mapping</A> type CTRL-K and then hit the function key, or use
   the form &quot;#1&quot;, &quot;#2&quot;, .. &quot;#9&quot;, &quot;#0&quot;, &quot;<A HREF="motion.html#&lt;Up&gt;">&lt;Up&gt;</A>&quot;, &quot;<A HREF="scroll.html#&lt;S-Down&gt;">&lt;S-Down&gt;</A>&quot;, &quot;&lt;S-F7&gt;&quot;, etc.
   (see table of keys |<A HREF="intro.html#key-notation">key-notation</A>|, all keys from <A HREF="motion.html#&lt;Up&gt;">&lt;Up&gt;</A> can be used).  The
   first ten function keys can be defined in two ways: Just the number, like
   &quot;#2&quot;, and with &quot;&lt;F&gt;&quot;, like &quot;&lt;F2&gt;&quot;.  Both stand for function key 2.  &quot;#0&quot;
   refers to function key 10.

DETAIL: Vim first checks if a sequence from the keyboard is mapped.  If <A HREF="motion.html#it">it</A>
isn't the <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> key codes are tried.  If a <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> code is found <A HREF="motion.html#it">it</A> is
replaced with the internal code.  Then the check for a <A HREF="#mapping">mapping</A> is done again
(so you can map an internal code to something else).  What is written into the
<A HREF="usr_41.html#script">script</A> file depends on what is recognized. If the <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> key code was
recognized <A HREF="motion.html#as">as</A> a <A HREF="#mapping">mapping</A> the key code itself is written to the <A HREF="usr_41.html#script">script</A> file.  If
<A HREF="motion.html#it">it</A> was recognized <A HREF="motion.html#as">as</A> a <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> code the internal code is written to the
<A HREF="usr_41.html#script">script</A> file.



1.6 SPECIAL CHARACTERS					*<A NAME=":map-special-chars"></A><B>:map-special-chars</B>*

						*<A NAME="map_backslash"></A><B>map_backslash</B>* *<A NAME="map-backslash"></A><B>map-backslash</B>*
Note that only <A HREF="visual.html#CTRL-V">CTRL-V</A> is mentioned here <A HREF="motion.html#as">as</A> a special character for mappings
and <A HREF="#abbreviations">abbreviations</A>.  When <A HREF="options.html#'cpoptions'">'cpoptions'</A> does not contain '<A HREF="motion.html#B">B</A>', a <A HREF="intro.html#backslash">backslash</A> can
also be used like <A HREF="visual.html#CTRL-V">CTRL-V</A>.  The &lt;&gt; <A HREF="intro.html#notation">notation</A> can be fully used then |<A HREF="intro.html#&lt;&gt;">&lt;&gt;</A>|.  But
you cannot use &quot;&lt;C-V&gt;&quot; like <A HREF="visual.html#CTRL-V">CTRL-V</A> to <A HREF="intro.html#escape">escape</A> the special meaning of what
follows.

To map a <A HREF="intro.html#backslash">backslash</A>, or use a <A HREF="intro.html#backslash">backslash</A> literally in the <A HREF="#{rhs}">{rhs}</A>, the special
sequence &quot;<A HREF="intro.html#&lt;Bslash&gt;">&lt;Bslash&gt;</A>&quot; can be used.  This avoids the need to double backslashes
when using nested mappings.


						*<A NAME="map_CTRL-C"></A><B>map_CTRL-C</B>* *<A NAME="map-CTRL-C"></A><B>map-CTRL-C</B>*
Using <A HREF="pattern.html#CTRL-C">CTRL-C</A> in the <A HREF="#{lhs}">{lhs}</A> is possible, but <A HREF="motion.html#it">it</A> will only work when Vim is
waiting for a key, not when Vim is busy with something.  When Vim is busy
<A HREF="pattern.html#CTRL-C">CTRL-C</A> interrupts/breaks the command.
When using the <A HREF="gui.html#GUI">GUI</A> version on MS-Windows <A HREF="pattern.html#CTRL-C">CTRL-C</A> can be mapped to allow a Copy
command to the <A HREF="provider.html#clipboard">clipboard</A>.  Use CTRL-Break to interrupt Vim.


					*<A NAME="map_space_in_lhs"></A><B>map_space_in_lhs</B>* *<A NAME="map-space_in_lhs"></A><B>map-space_in_lhs</B>*
To include a space in <A HREF="#{lhs}">{lhs}</A> precede <A HREF="motion.html#it">it</A> with a <A HREF="visual.html#CTRL-V">CTRL-V</A> (type two CTRL-Vs for
each space).

					*<A NAME="map_space_in_rhs"></A><B>map_space_in_rhs</B>* *<A NAME="map-space_in_rhs"></A><B>map-space_in_rhs</B>*
If you want a <A HREF="#{rhs}">{rhs}</A> that starts with a space, use &quot;<A HREF="motion.html#&lt;Space&gt;">&lt;Space&gt;</A>&quot;.  To be fully <A HREF="intro.html#Vi">Vi</A>
compatible (but unreadable) don't use the |<A HREF="intro.html#&lt;&gt;">&lt;&gt;</A>| <A HREF="intro.html#notation">notation</A>, precede <A HREF="#{rhs}">{rhs}</A> with a
single <A HREF="visual.html#CTRL-V">CTRL-V</A> (you have to type <A HREF="visual.html#CTRL-V">CTRL-V</A> two times).

						*<A NAME="map_empty_rhs"></A><B>map_empty_rhs</B>* *<A NAME="map-empty-rhs"></A><B>map-empty-rhs</B>*
You can create an empty <A HREF="#{rhs}">{rhs}</A> by typing nothing after a single <A HREF="visual.html#CTRL-V">CTRL-V</A> (you
have to type <A HREF="visual.html#CTRL-V">CTRL-V</A> two times).  Unfortunately, you cannot <A HREF="diff.html#do">do</A> this in a <A HREF="starting.html#vimrc">vimrc</A>
file.

							*<A NAME="&lt;Nop&gt;"></A><B>&lt;Nop&gt;</B>*
An easier way to get a <A HREF="#mapping">mapping</A> that doesn't produce anything, is to use
&quot;<A HREF="#&lt;Nop&gt;">&lt;Nop&gt;</A>&quot; for the <A HREF="#{rhs}">{rhs}</A>.  This only works when the |<A HREF="intro.html#&lt;&gt;">&lt;&gt;</A>| <A HREF="intro.html#notation">notation</A> is enabled.
For example, to make sure that function key 8 does nothing at all:
<B>	:map  &lt;F8&gt;  &lt;Nop&gt;</B>
<B>	:map! &lt;F8&gt;  &lt;Nop&gt;</B>
 

							*<A NAME="map-multibyte"></A><B>map-multibyte</B>*
It is possible to map <A HREF="mbyte.html#multibyte">multibyte</A> characters, but only the whole character.  You
cannot map the first byte only.  This was done to prevent problems in this
scenario:
<B>	:set encoding=latin1</B>
<B>	:imap &lt;M-C&gt; foo</B>
<B>	:set encoding=utf-8</B>
The <A HREF="#mapping">mapping</A> for &lt;M-C&gt; is defined with the latin1 encoding, resulting in a 0xc3
byte.  If you type the character &aacute; (0xe1 &lt;M-a&gt;) in <A HREF="mbyte.html#UTF-8">UTF-8</A> encoding this is the
two bytes 0xc3 0xa1.  You don't want the 0xc3 byte to be mapped then or
otherwise <A HREF="motion.html#it">it</A> would be impossible to type the  character.


					*<A NAME="&lt;Leader&gt;"></A><B>&lt;Leader&gt;</B>* *<A NAME="mapleader"></A><B>mapleader</B>*
To define a <A HREF="#mapping">mapping</A> which uses the &quot;<A HREF="#mapleader">mapleader</A>&quot; variable, the special <A HREF="eval.html#string">string</A>
&quot;<A HREF="#&lt;Leader&gt;">&lt;Leader&gt;</A>&quot; can be used.  It is replaced with the <A HREF="eval.html#string">string</A> value of &quot;<A HREF="#mapleader">mapleader</A>&quot;.
If &quot;<A HREF="#mapleader">mapleader</A>&quot; is not set or empty, a <A HREF="intro.html#backslash">backslash</A> is used instead.  Example:
<B>	:map &lt;Leader&gt;A  oanother line&lt;Esc&gt;</B>
Works like:
<B>	:map \A  oanother line&lt;Esc&gt;</B>
But after:
<B>	:let mapleader = ","</B>
It works like:
<B>	:map ,A  oanother line&lt;Esc&gt;</B>

Note that the value of &quot;<A HREF="#mapleader">mapleader</A>&quot; is used at the moment the <A HREF="#mapping">mapping</A> is
defined.  Changing &quot;<A HREF="#mapleader">mapleader</A>&quot; after that has no effect for already defined
mappings.


					*<A NAME="&lt;LocalLeader&gt;"></A><B>&lt;LocalLeader&gt;</B>* *<A NAME="maplocalleader"></A><B>maplocalleader</B>*
<A HREF="#&lt;LocalLeader&gt;">&lt;LocalLeader&gt;</A> is just like <A HREF="#&lt;Leader&gt;">&lt;Leader&gt;</A>, except that <A HREF="motion.html#it">it</A> uses &quot;<A HREF="#maplocalleader">maplocalleader</A>&quot;
instead of &quot;<A HREF="#mapleader">mapleader</A>&quot;.  <A HREF="#&lt;LocalLeader&gt;">&lt;LocalLeader&gt;</A> is to be used for mappings which are
local to a buffer.  Example:
<B>      :map &lt;buffer&gt; &lt;LocalLeader&gt;A  oanother line&lt;Esc&gt;</B>
 
In a global <A HREF="usr_05.html#plugin">plugin</A> <A HREF="#&lt;Leader&gt;">&lt;Leader&gt;</A> should be used and in a <A HREF="filetype.html#filetype">filetype</A> <A HREF="usr_05.html#plugin">plugin</A>
<A HREF="#&lt;LocalLeader&gt;">&lt;LocalLeader&gt;</A>.  &quot;<A HREF="#mapleader">mapleader</A>&quot; and &quot;<A HREF="#maplocalleader">maplocalleader</A>&quot; can be equal.  Although, if
you make them different, there is a smaller chance of mappings from global
plugins to clash with mappings for <A HREF="filetype.html#filetype">filetype</A> plugins.  For example, you could
keep &quot;<A HREF="#mapleader">mapleader</A>&quot; at the default <A HREF="intro.html#backslash">backslash</A>, and set &quot;<A HREF="#maplocalleader">maplocalleader</A>&quot; to an
underscore.


							*<A NAME="map-&lt;SID&gt;"></A><B>map-&lt;SID&gt;</B>*
In a <A HREF="usr_41.html#script">script</A> the special key name &quot;<A HREF="#&lt;SID&gt;">&lt;SID&gt;</A>&quot; can be used to define a <A HREF="#mapping">mapping</A>
that's local to the <A HREF="usr_41.html#script">script</A>.  See |<A HREF="#&lt;SID&gt;">&lt;SID&gt;</A>| for details.


							*<A NAME="&lt;Plug&gt;"></A><B>&lt;Plug&gt;</B>*
The special key name &quot;<A HREF="#&lt;Plug&gt;">&lt;Plug&gt;</A>&quot; can be used for an internal <A HREF="#mapping">mapping</A>, which is
not to be matched with any key sequence.  This is useful in plugins
|<A HREF="usr_41.html#using-&lt;Plug&gt;">using-&lt;Plug&gt;</A>|.


							*<A NAME="&lt;Char&gt;"></A><B>&lt;Char&gt;</B>* *<A NAME="&lt;Char-&gt;"></A><B>&lt;Char-&gt;</B>*
To map a character by its decimal, <A HREF="eval.html#octal">octal</A> or hexadecimal number the <A HREF="#&lt;Char&gt;">&lt;Char&gt;</A>
construct can be used:
	&lt;Char-123&gt;	character 123
	&lt;Char-033&gt;	character 27
	&lt;Char-0x7f&gt;	character 127
	&lt;S-Char-114&gt;    character 114 ('<A HREF="change.html#r">r</A>') shifted ('<A HREF="change.html#R">R</A>')
This is useful to specify a (multi-byte) character in a <A HREF="options.html#'keymap'">'keymap'</A> file.
Upper and <A HREF="change.html#lowercase">lowercase</A> differences are ignored.


							*<A NAME="map-comments"></A><B>map-comments</B>*
It is not possible to put a comment after these commands, because the &#39;&#34;''
character is considered to be part of the <A HREF="#{lhs}">{lhs}</A> or <A HREF="#{rhs}">{rhs}</A>. However, one can
use |&quot;, since this starts a new, empty command with a comment.


							*<A NAME="map_bar"></A><B>map_bar</B>* *<A NAME="map-bar"></A><B>map-bar</B>*
Since the '&#124;' character is used to separate a map command from the next
command, you will have to <A HREF="diff.html#do">do</A> something special to include  a '&#124;' in <A HREF="#{rhs}">{rhs}</A>.
There are three methods:
<B><FONT color="#54A23D">   use	     works when			   example	</FONT></B>
   <A HREF="intro.html#&lt;Bar&gt;">&lt;Bar&gt;</A>     always			   <A HREF="#:map">:map</A> _l :!ls <A HREF="intro.html#&lt;Bar&gt;">&lt;Bar&gt;</A> more^M
   \&#124;	     '<A HREF="motion.html#b">b</A>' is not in <A HREF="options.html#'cpoptions'">'cpoptions'</A>	   <A HREF="#:map">:map</A> _l :!ls \&#124; more^M
   ^V&#124;	     always			   <A HREF="#:map">:map</A> _l :!ls ^V&#124; more^M

(here ^V stands for <A HREF="visual.html#CTRL-V">CTRL-V</A>; to get one <A HREF="visual.html#CTRL-V">CTRL-V</A> you have to type <A HREF="motion.html#it">it</A> <A HREF="if_cscop.html#twice">twice</A>; you
cannot use the <A HREF="intro.html#&lt;&gt;">&lt;&gt;</A> <A HREF="intro.html#notation">notation</A> &quot;&lt;C-V&gt;&quot; here).

All three work when you use the default setting for <A HREF="options.html#'cpoptions'">'cpoptions'</A>.

When '<A HREF="motion.html#b">b</A>' is present in <A HREF="options.html#'cpoptions'">'cpoptions'</A>, &quot;\|&quot; will be recognized <A HREF="motion.html#as">as</A> a <A HREF="#mapping">mapping</A>
ending in a '\' and then another command.  This is <A HREF="intro.html#Vi">Vi</A> compatible, but
illogical when compared to other commands.


						*<A NAME="map_return"></A><B>map_return</B>* *<A NAME="map-return"></A><B>map-return</B>*
When you have a <A HREF="#mapping">mapping</A> that contains an <A HREF="intro.html#Ex">Ex</A> command, you need to put a line
terminator after <A HREF="motion.html#it">it</A> to have <A HREF="motion.html#it">it</A> executed.  The use of <A HREF="motion.html#&lt;CR&gt;">&lt;CR&gt;</A> is recommended for
this (see |<A HREF="intro.html#&lt;&gt;">&lt;&gt;</A>|).  Example:
<B>   :map  _ls  :!ls -l %:S&lt;CR&gt;:echo "the end"&lt;CR&gt;</B>

To avoid <A HREF="#mapping">mapping</A> of the characters you type in insert or <A HREF="cmdline.html#Command-line">Command-line</A> mode,
type a <A HREF="visual.html#CTRL-V">CTRL-V</A> first.  The <A HREF="#mapping">mapping</A> in <A HREF="insert.html#Insert">Insert</A> mode is disabled if the <A HREF="options.html#'paste'">'paste'</A>
option is on.

							*<A NAME="map-error"></A><B>map-error</B>*
Note that when an error is encountered (that causes an error message or beep)
the rest of the <A HREF="#mapping">mapping</A> is not executed.  This is Vi-compatible.

Note that the second character (argument) of the commands @zZtTfF[]rm'`&quot;v
and <A HREF="change.html#CTRL-X">CTRL-X</A> is not mapped.  This was done to be able to use all the named
<A HREF="change.html#registers">registers</A> and marks, even when the command with the same name has been
mapped.



1.7 WHAT KEYS TO MAP					*<A NAME="map-which-keys"></A><B>map-which-keys</B>*

If you are going to map something, you will need to choose which key(s) to use
for the <A HREF="#{lhs}">{lhs}</A>.  You will have to avoid keys that are used for Vim commands,
otherwise you would not be able to use those commands anymore.  Here are a few
suggestions:
- Function keys &lt;F2&gt;, &lt;F3&gt;, etc..  Also the shifted function keys <A HREF="intro.html#&lt;S-F1&gt;">&lt;S-F1&gt;</A>,
  &lt;S-F2&gt;, etc.  Note that <A HREF="helphelp.html#&lt;F1&gt;">&lt;F1&gt;</A> is already used for the help command.
- Meta-keys (with the ALT key pressed).  Depending on your keyboard accented
  characters may be used <A HREF="motion.html#as">as</A> well. |<A HREF="#:map-alt-keys">:map-alt-keys</A>|
- Use the '<A HREF="motion.html#_">_</A>' or '<A HREF="motion.html#,">,</A>' character and then any other character.  The &quot;<A HREF="motion.html#_">_</A>&quot; and &quot;<A HREF="motion.html#,">,</A>&quot;
  commands <A HREF="diff.html#do">do</A> exist in Vim (see |<A HREF="motion.html#_">_</A>| and |<A HREF="motion.html#,">,</A>|), but you probably never use them.
- Use a key that is a synonym for another command.  For example: <A HREF="motion.html#CTRL-P">CTRL-P</A> and
  <A HREF="motion.html#CTRL-N">CTRL-N</A>.  Use an extra character to allow more mappings.
- The key defined by <A HREF="#&lt;Leader&gt;">&lt;Leader&gt;</A> and one or more other keys.  This is especially
  useful in scripts. |<A HREF="#mapleader">mapleader</A>|

See the file &quot;index&quot; for keys that are not used and thus can be mapped without
losing any builtin function.  You can also use &quot;<A HREF="helphelp.html#:help">:help</A> {key}^D&quot; to find out if
a key is used for some command.  ({key} is the specific key you want to find
out about, ^D is <A HREF="scroll.html#CTRL-D">CTRL-D</A>).



1.8 EXAMPLES						*<A NAME="map-examples"></A><B>map-examples</B>*

A few examples (as you type them: for &quot;<A HREF="motion.html#&lt;CR&gt;">&lt;CR&gt;</A>&quot; you type four characters).

<B>   :map &lt;F3&gt;  o#include</B>
<B>   :map &lt;M-g&gt; /foo&lt;CR&gt;cwbar&lt;Esc&gt;</B>
<B>   :map _x    d/END/e&lt;CR&gt;</B>
<B>   :map! qq   quadrillion questions</B>


Multiplying a <A HREF="intro.html#count">count</A>

When you type a <A HREF="intro.html#count">count</A> before triggering a <A HREF="#mapping">mapping</A>, it's like the <A HREF="intro.html#count">count</A> was
typed before the <A HREF="#{lhs}">{lhs}</A>.  For example, with this <A HREF="#mapping">mapping</A>:
<B>   :map &lt;F4&gt;  3w</B>
Typing 2&lt;F4&gt; will result in &quot;23w&quot;. Thus not moving 2 &#42; 3 words but 23 words.
If you want to multiply counts use the <A HREF="eval.html#expression">expression</A> <A HREF="sponsor.html#register">register</A>:
<B>   :map &lt;F4&gt;  @='3w'&lt;CR&gt;</B>
The part between quotes is the <A HREF="eval.html#expression">expression</A> being executed. |<A HREF="change.html#@=">@=</A>|



1.9 USING MAPPINGS					*<A NAME="map-typing"></A><B>map-typing</B>*

Vim will compare what you type with the start of a mapped sequence.  If there
is an incomplete match, <A HREF="motion.html#it">it</A> will get more characters until there either is a
complete match or until there is no match at all.  Example: If you map! &quot;qq&quot;,
the first '<A HREF="repeat.html#q">q</A>' will not appear on the screen until you type another
character.  This is because Vim cannot know if the next character will be a
'<A HREF="repeat.html#q">q</A>' or not.  If the <A HREF="options.html#'timeout'">'timeout'</A> option is on (which is the default) Vim will
only wait for one second (or <A HREF="motion.html#as">as</A> long <A HREF="motion.html#as">as</A> specified with the <A HREF="options.html#'timeoutlen'">'timeoutlen'</A>
option).  After that <A HREF="motion.html#it">it</A> assumes that the '<A HREF="repeat.html#q">q</A>' is to be interpreted <A HREF="motion.html#as">as</A> such.  If
you type slowly, or your system is slow, reset the <A HREF="options.html#'timeout'">'timeout'</A> option.  Then you
might want to set the <A HREF="options.html#'ttimeout'">'ttimeout'</A> option.


			      				*<A NAME="map-precedence"></A><B>map-precedence</B>*
Buffer-local mappings (defined using |<A HREF="#:map-&lt;buffer&gt;">:map-&lt;buffer&gt;</A>|) take precedence over
global mappings.  When a buffer-local <A HREF="#mapping">mapping</A> is the same <A HREF="motion.html#as">as</A> a global <A HREF="#mapping">mapping</A>,
Vim will use the buffer-local <A HREF="#mapping">mapping</A>.  In addition, Vim will use a complete
<A HREF="#mapping">mapping</A> immediately if <A HREF="motion.html#it">it</A> was defined with &lt;nowait&gt;, even if a longer <A HREF="#mapping">mapping</A>
has the same prefix.  For example, given the following two mappings:
<B>    :map &lt;buffer&gt; &lt;nowait&gt; \a   :echo "Local \a"&lt;CR&gt;</B>
<B>    :map                   \abc :echo "Global \abc"&lt;CR&gt;</B>
When typing \a the buffer-local <A HREF="#mapping">mapping</A> will be used immediately.  Vim will
not wait for more characters to see if the user might be typing \abc.


							*<A NAME="map-keys-fails"></A><B>map-keys-fails</B>*
There are situations where key codes might not be recognized:
- Vim can only read part of the key code.  Mostly this is only the first
  character.  This happens on some Unix versions in an xterm.
- The key code is after character(s) that are mapped.  E.g., &quot;&lt;F1&gt;&lt;F1&gt;&quot; or
  &quot;g&lt;F1&gt;&quot;.

The result is that the key code is not recognized in this situation, and the
<A HREF="#mapping">mapping</A> fails.  There are two actions needed to avoid this problem:

- Remove the '<A HREF="various.html#K">K</A>' flag from <A HREF="options.html#'cpoptions'">'cpoptions'</A>.  This will make Vim wait for the rest
  of the characters of the function key.
- When using <A HREF="helphelp.html#&lt;F1&gt;">&lt;F1&gt;</A> to &lt;F4&gt; the actual key code generated may correspond to
  &lt;xF1&gt; to &lt;xF4&gt;.  There are mappings from &lt;xF1&gt; to <A HREF="helphelp.html#&lt;F1&gt;">&lt;F1&gt;</A>, &lt;xF2&gt; to &lt;F2&gt;, etc.,
  but these are not recognized after another half a <A HREF="#mapping">mapping</A>.  Make sure the
  key codes for <A HREF="helphelp.html#&lt;F1&gt;">&lt;F1&gt;</A> to &lt;F4&gt; are correct:
<B>	:set &lt;F1&gt;=&lt;type CTRL-V&gt;&lt;type F1&gt;</B>
  Type the <A HREF="helphelp.html#&lt;F1&gt;">&lt;F1&gt;</A> <A HREF="motion.html#as">as</A> four characters.  The part after the &quot;<A HREF="change.html#=">=</A>&quot; must be done with
  the actual keys, not the literal text.
Another solution is to use the actual key code in the <A HREF="#mapping">mapping</A> for the second
special key:
<B>	:map &lt;F1&gt;&lt;Esc&gt;OP :echo "yes"&lt;CR&gt;</B>
Don't type a real <A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A>, Vim will recognize the key code and replace <A HREF="motion.html#it">it</A> with
<A HREF="helphelp.html#&lt;F1&gt;">&lt;F1&gt;</A> anyway.


						*<A NAME="recursive_mapping"></A><B>recursive_mapping</B>*
If you include the <A HREF="#{lhs}">{lhs}</A> in the <A HREF="#{rhs}">{rhs}</A> you have a recursive <A HREF="#mapping">mapping</A>.  When
<A HREF="#{lhs}">{lhs}</A> is typed, <A HREF="motion.html#it">it</A> will be replaced with <A HREF="#{rhs}">{rhs}</A>.  When the <A HREF="#{lhs}">{lhs}</A> which is
included in <A HREF="#{rhs}">{rhs}</A> is encountered <A HREF="motion.html#it">it</A> will be replaced with <A HREF="#{rhs}">{rhs}</A>, and so on.
This makes <A HREF="motion.html#it">it</A> possible to repeat a command an infinite number of times.  The
only problem is that the only way to stop this is by causing an error.  The
macros to solve a maze uses this, look there for an example.  There is one
exception: If the <A HREF="#{rhs}">{rhs}</A> starts with <A HREF="#{lhs}">{lhs}</A>, the first character is not mapped
again (this is <A HREF="intro.html#Vi">Vi</A> compatible).
For example:
<B>   :map ab abcd</B>
will execute the &quot;<A HREF="insert.html#a">a</A>&quot; command and insert &quot;bcd&quot; in the text.  The &quot;<A HREF="motion.html#ab">ab</A>&quot; in the
<A HREF="#{rhs}">{rhs}</A> will not be mapped again.

If you want to exchange the meaning of two keys you should use the <A HREF="#:noremap">:noremap</A>
command.  For example:
<B>   :noremap k j</B>
<B>   :noremap j k</B>
This will exchange the cursor up and down commands.

With the normal <A HREF="#:map">:map</A> command, when the <A HREF="options.html#'remap'">'remap'</A> option is on, <A HREF="#mapping">mapping</A> takes
place until the text is found not to be a part of a <A HREF="#{lhs}">{lhs}</A>.  For example, if
you use:
<B>   :map x y</B>
<B>   :map y x</B>
Vim will replace <A HREF="change.html#x">x</A> with <A HREF="change.html#y">y</A>, and then <A HREF="change.html#y">y</A> with <A HREF="change.html#x">x</A>, etc.  When this has happened
<A HREF="options.html#'maxmapdepth'">'maxmapdepth'</A> times (default 1000), Vim will give the error message
&quot;recursive mapping&quot;.


							*<A NAME=":map-undo"></A><B>:map-undo</B>*
If you include an <A HREF="undo.html#undo">undo</A> command inside a mapped sequence, this will bring the
text back in the state before executing the <A HREF="#macro">macro</A>.  This is compatible with
the original <A HREF="intro.html#Vi">Vi</A>, <A HREF="motion.html#as">as</A> long <A HREF="motion.html#as">as</A> there is only one <A HREF="undo.html#undo">undo</A> command in the mapped
sequence (having two <A HREF="undo.html#undo">undo</A> commands in a mapped sequence did not make sense
in the original <A HREF="intro.html#Vi">Vi</A>, you would get back the text before the first <A HREF="undo.html#undo">undo</A>).



1.10 MAPPING ALT-KEYS					*<A NAME=":map-alt-keys"></A><B>:map-alt-keys</B>*

In the <A HREF="gui.html#GUI">GUI</A> Nvim handles the |<A HREF="intro.html#ALT">ALT</A>| key itself, thus <A HREF="#mapping">mapping</A> keys with ALT
should always work.  But in a <A HREF="nvim_terminal_emulator.html#terminal">terminal</A> Nvim gets a sequence of bytes and has
to figure out whether ALT was pressed.  Terminals may use ESC to indicate that
ALT was pressed.  If ESC is followed by a {key} within <A HREF="options.html#'ttimeoutlen'">'ttimeoutlen'</A>
milliseconds, the ESC is interpreted <A HREF="motion.html#as">as</A>:
        &lt;ALT-{key}&gt;
otherwise <A HREF="motion.html#it">it</A> is interpreted <A HREF="motion.html#as">as</A> two key presses:
        &lt;ESC&gt; {key}


1.11 MAPPING AN OPERATOR				*<A NAME=":map-operator"></A><B>:map-operator</B>*

An <A HREF="motion.html#operator">operator</A> is used before a <A HREF="intro.html#{motion}">{motion}</A> command.  To define your own <A HREF="motion.html#operator">operator</A>
you must create <A HREF="#mapping">mapping</A> that first sets the <A HREF="options.html#'operatorfunc'">'operatorfunc'</A> option and then
invoke the |<A HREF="#g@"><span class="__cf_email__" data-cfemail="0b6c4b">[email&#160;protected]</span></A>| <A HREF="motion.html#operator">operator</A>.  After the user types the <A HREF="intro.html#{motion}">{motion}</A> command the
specified function will be called.


							*<A NAME="g@"></A><B><a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="157255">[email&#160;protected]</a></B>* *<A NAME="E774"></A><B>E774</B>* *<A NAME="E775"></A><B>E775</B>*
<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="98ffd8">[email&#160;protected]</a>{motion}		Call the function set by the <A HREF="options.html#'operatorfunc'">'operatorfunc'</A> option.
			The <A HREF="motion.html#'[">'[</A> <A HREF="motion.html#mark">mark</A> is positioned at the start of the text
			moved over by <A HREF="intro.html#{motion}">{motion}</A>, the <A HREF="motion.html#']">']</A> <A HREF="motion.html#mark">mark</A> on the last
			character of the text.
			The function is called with one <A HREF="eval.html#String">String</A> argument:
			    &quot;line&quot;	<A HREF="intro.html#{motion}">{motion}</A> was |<A HREF="motion.html#linewise">linewise</A>|
			    &quot;char&quot;	<A HREF="intro.html#{motion}">{motion}</A> was |<A HREF="motion.html#characterwise">characterwise</A>|
			    &quot;block&quot;	<A HREF="intro.html#{motion}">{motion}</A> was |<A HREF="visual.html#blockwise-visual">blockwise-visual</A>|
			Although &quot;block&quot; would rarely appear, since <A HREF="motion.html#it">it</A> can
			only result from <A HREF="visual.html#Visual">Visual</A> mode where &quot;<A HREF="#g@"><span class="__cf_email__" data-cfemail="600720">[email&#160;protected]</span></A>&quot; is not useful.
			{not available when compiled without the |<A HREF="various.html#+eval">+eval</A>|
			feature}

Here is an example that counts the number of spaces with &lt;F4&gt;:

<B>	nmap &lt;silent&gt; &lt;F4&gt; :set opfunc=CountSpaces&lt;CR&gt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="80e7c0">[email&#160;protected]</a></B>
<B>	vmap &lt;silent&gt; &lt;F4&gt; :&lt;C-U&gt;call CountSpaces(visualmode(), 1)&lt;CR&gt;</B>

<B>	function! CountSpaces(type, ...)</B>
<B>	  let sel_save = &amp;selection</B>
<B>	  let &amp;selection = "inclusive"</B>
<B>	  let reg_save = @@</B>

<B>	  if a:0  " Invoked from Visual mode, use gv command.</B>
<B>	    silent exe "normal! gvy"</B>
<B>	  elseif a:type == 'line'</B>
<B>	    silent exe "normal! '[V']y"</B>
<B>	  else</B>
<B>	    silent exe "normal! `[v`]y"</B>
<B>	  endif</B>

<B>	  echomsg strlen(substitute(@@, '[^ ]', '', 'g'))</B>

<B>	  let &amp;selection = sel_save</B>
<B>	  let @@ = reg_save</B>
<B>	endfunction</B>

Note that the <A HREF="options.html#'selection'">'selection'</A> option is temporarily set to &quot;<A HREF="motion.html#inclusive">inclusive</A>&quot; to be able
to <A HREF="change.html#yank">yank</A> exactly the right text by using <A HREF="visual.html#Visual">Visual</A> mode from the <A HREF="motion.html#'[">'[</A> to the <A HREF="motion.html#']">']</A>
<A HREF="motion.html#mark">mark</A>.

Also note that there is a separate <A HREF="#mapping">mapping</A> for <A HREF="visual.html#Visual">Visual</A> mode.  It removes the
&quot;'&lt;,'&gt;&quot; range that &quot;<A HREF="cmdline.html#:">:</A>&quot; inserts in <A HREF="visual.html#Visual">Visual</A> mode and invokes the function with
<A HREF="eval.html#visualmode()">visualmode()</A> and an extra argument.

==============================================================================

2. <A HREF="#Abbreviations">Abbreviations</A>			*<A NAME="abbreviations"></A><B>abbreviations</B>* *<A NAME="Abbreviations"></A><B>Abbreviations</B>*

<A HREF="#Abbreviations">Abbreviations</A> are used in <A HREF="insert.html#Insert">Insert</A> mode, <A HREF="insert.html#Replace">Replace</A> mode and <A HREF="cmdline.html#Command-line">Command-line</A> mode.
If you enter a <A HREF="motion.html#word">word</A> that is an abbreviation, <A HREF="motion.html#it">it</A> is replaced with the <A HREF="motion.html#word">word</A> <A HREF="motion.html#it">it</A>
stands for.  This can be used to save typing for often used long words.  And
you can use <A HREF="motion.html#it">it</A> to automatically correct obvious spelling <A HREF="message.html#errors">errors</A>.
Examples:

	:iab ms Microsoft
	:iab tihs this

There are three types of <A HREF="#abbreviations">abbreviations</A>:

full-id	  The &quot;full-id&quot; type consists entirely of keyword characters (letters
	  and characters from <A HREF="options.html#'iskeyword'">'iskeyword'</A> option).  This is the most common
	  abbreviation.

	  Examples: &quot;foo&quot;, &quot;g3&quot;, &quot;-1&quot;

end-id	  The &quot;end-id&quot; type ends in a keyword character, but all the other
	  characters are not keyword characters.

	  Examples: &quot;#i&quot;, &quot;..f&quot;, &quot;$/7&quot;

non-id	  The &quot;non-id&quot; type ends in a non-keyword character, the other
	  characters may be of any type, excluding space and <A HREF="intro.html#tab">tab</A>.

	  Examples: &quot;def#&quot;, &quot;4/7$&quot;

Examples of strings that cannot be <A HREF="#abbreviations">abbreviations</A>: &quot;a.b&quot;, &quot;#def&quot;, &quot;a b&quot;, &quot;_$r&quot;

An abbreviation is only recognized when you type a non-keyword character.
This can also be the <A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A> that ends insert mode or the <A HREF="motion.html#&lt;CR&gt;">&lt;CR&gt;</A> that ends a
command.  The non-keyword character which ends the abbreviation is inserted
after the expanded abbreviation.  An exception to this is the character &lt;C-]&gt;,
which is used to expand an abbreviation without <A HREF="insert.html#inserting">inserting</A> any extra
characters.

Example:
<B>   :ab hh	hello</B>
 	    &quot;hh&lt;Space&gt;&quot; is expanded to &quot;hello&lt;Space&gt;&quot;
	    &quot;hh&lt;C-]&gt;&quot; is expanded to &quot;hello&quot;

The characters before the cursor must match the abbreviation.  Each type has
an additional rule:

full-id	  In front of the match is a non-keyword character, or this is where
	  the line or insertion starts.  Exception: When the abbreviation is
	  only one character, <A HREF="motion.html#it">it</A> is not recognized if there is a non-keyword
	  character in front of <A HREF="motion.html#it">it</A>, other than a space or a <A HREF="intro.html#tab">tab</A>.

end-id	  In front of the match is a keyword character, or a space or a <A HREF="intro.html#tab">tab</A>,
	  or this is where the line or insertion starts.

non-id	  In front of the match is a space, <A HREF="intro.html#tab">tab</A> or the start of the line or
	  the insertion.

Examples: ({CURSOR} is where you type a non-keyword character)
<B>   :ab foo   four old otters</B>
 		&quot; foo{CURSOR}&quot;	  is expanded to &quot; four old otters&quot;
		&quot; foobar{CURSOR}&quot; is not expanded
		&quot;barfoo{CURSOR}&quot;  is not expanded

<B>   :ab #i #include</B>
 		&quot;#i{CURSOR}&quot;	  is expanded to &quot;#include&quot;
		&quot;&gt;#i{CURSOR}&quot;	  is not expanded

<B>   :ab ;; &lt;endofline&gt;</B>
 		&quot;test;;&quot;	  is not expanded
		&quot;test ;;&quot;	  is expanded to &quot;test &lt;endofline&gt;&quot;

To avoid the abbreviation in <A HREF="insert.html#Insert">Insert</A> mode: Type <A HREF="visual.html#CTRL-V">CTRL-V</A> before the character
that would trigger the abbreviation.  E.g. <A HREF="visual.html#CTRL-V">CTRL-V</A> <A HREF="motion.html#&lt;Space&gt;">&lt;Space&gt;</A>.  Or type part of
the abbreviation, exit insert mode with <A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A>, re-enter insert mode with &quot;<A HREF="insert.html#a">a</A>&quot;
and type the rest.

To avoid the abbreviation in <A HREF="cmdline.html#Command-line">Command-line</A> mode: Type <A HREF="visual.html#CTRL-V">CTRL-V</A> <A HREF="if_cscop.html#twice">twice</A> somewhere in
the abbreviation to avoid <A HREF="motion.html#it">it</A> to be replaced.  A <A HREF="visual.html#CTRL-V">CTRL-V</A> in front of a normal
character is mostly ignored otherwise.

It is possible to move the cursor after an abbreviation:
<B>   :iab if if ()&lt;Left&gt;</B>

You can even <A HREF="diff.html#do">do</A> more complicated things.  For example, to consume the space
typed after an abbreviation:
<B>   func Eatchar(pat)</B>
<B>      let c = nr2char(getchar(0))</B>
<B>      return (c =~ a:pat) ? '' : c</B>
<B>   endfunc</B>
<B>   iabbr &lt;silent&gt; if if ()&lt;Left&gt;&lt;C-R&gt;=Eatchar('\s')&lt;CR&gt;</B>

There are no default <A HREF="#abbreviations">abbreviations</A>.

<A HREF="#Abbreviations">Abbreviations</A> are never recursive.  You can use &quot;<A HREF="#:ab">:ab</A> <A HREF="motion.html#f">f</A> f-o-o&quot; without any
problem.  But <A HREF="#abbreviations">abbreviations</A> can be mapped.  {some versions of <A HREF="intro.html#Vi">Vi</A> support
recursive <A HREF="#abbreviations">abbreviations</A>, for no apparent reason}

<A HREF="#Abbreviations">Abbreviations</A> are disabled if the <A HREF="options.html#'paste'">'paste'</A> option is on.


				*<A NAME=":abbreviate-local"></A><B>:abbreviate-local</B>* *<A NAME=":abbreviate-&lt;buffer&gt;"></A><B>:abbreviate-&lt;buffer&gt;</B>*
Just like mappings, <A HREF="#abbreviations">abbreviations</A> can be local to a buffer.  This is mostly
used in a |<A HREF="usr_43.html#filetype-plugin">filetype-plugin</A>| file.  Example for a C plugin file:
<B>	:abb &lt;buffer&gt; FF  for (i = 0; i &lt; ; ++i)</B>
 

						*<A NAME=":ab"></A><B>:ab</B>* *<A NAME=":abbreviate"></A><B>:abbreviate</B>*
:ab[breviate]		<A HREF="eval.html#list">list</A> all <A HREF="#abbreviations">abbreviations</A>.  The character in the first
			column indicates the mode where the abbreviation is
			used: '<A HREF="insert.html#i">i</A>' for insert mode, '<A HREF="change.html#c">c</A>' for <A HREF="cmdline.html#Command-line">Command-line</A>
			mode, '<A HREF="change.html#!">!</A>' for both.  These are the same <A HREF="motion.html#as">as</A> for
			mappings, see |<A HREF="#map-listing">map-listing</A>|.


						*<A NAME=":abbreviate-verbose"></A><B>:abbreviate-verbose</B>*
When <A HREF="options.html#'verbose'">'verbose'</A> is non-zero, listing an abbreviation will also display where <A HREF="motion.html#it">it</A>
was last defined.  Example:

<B>	:verbose abbreviate</B>
<B>	!  teh		 the</B>
<B>		Last set from /home/abcd/vim/abbr.vim</B>

See |<A HREF="various.html#:verbose-cmd">:verbose-cmd</A>| for more information.

:ab[breviate] <A HREF="#{lhs}">{lhs}</A>	<A HREF="eval.html#list">list</A> the <A HREF="#abbreviations">abbreviations</A> that start with <A HREF="#{lhs}">{lhs}</A>
			You may need to insert a <A HREF="visual.html#CTRL-V">CTRL-V</A> (type <A HREF="motion.html#it">it</A> <A HREF="if_cscop.html#twice">twice</A>) to
			avoid that a typed <A HREF="#{lhs}">{lhs}</A> is expanded, since
			command-line <A HREF="#abbreviations">abbreviations</A> apply here.

:ab[breviate] [&lt;expr&gt;] [&lt;buffer&gt;] <A HREF="#{lhs}">{lhs}</A> <A HREF="#{rhs}">{rhs}</A>
			add abbreviation for <A HREF="#{lhs}">{lhs}</A> to <A HREF="#{rhs}">{rhs}</A>.  If <A HREF="#{lhs}">{lhs}</A> already
			existed <A HREF="motion.html#it">it</A> is replaced with the new <A HREF="#{rhs}">{rhs}</A>.  <A HREF="#{rhs}">{rhs}</A> may
			contain spaces.
			See |<A HREF="#:map-&lt;expr&gt;">:map-&lt;expr&gt;</A>| for the optional &lt;expr&gt; argument.
			See |<A HREF="#:map-&lt;buffer&gt;">:map-&lt;buffer&gt;</A>| for the optional &lt;buffer&gt; argument.


						*<A NAME=":una"></A><B>:una</B>* *<A NAME=":unabbreviate"></A><B>:unabbreviate</B>*
:una[bbreviate] <A HREF="#{lhs}">{lhs}</A>	Remove abbreviation for <A HREF="#{lhs}">{lhs}</A> from the <A HREF="eval.html#list">list</A>.  If none
			is found, remove <A HREF="#abbreviations">abbreviations</A> in which <A HREF="#{lhs}">{lhs}</A> matches
			with the <A HREF="#{rhs}">{rhs}</A>.  This is done so that you can even
			remove <A HREF="#abbreviations">abbreviations</A> after expansion.  To avoid
			expansion insert a <A HREF="visual.html#CTRL-V">CTRL-V</A> (type <A HREF="motion.html#it">it</A> <A HREF="if_cscop.html#twice">twice</A>).


						*<A NAME=":norea"></A><B>:norea</B>* *<A NAME=":noreabbrev"></A><B>:noreabbrev</B>*
:norea[bbrev] [&lt;expr&gt;] [&lt;buffer&gt;] [lhs] [rhs]
			same <A HREF="motion.html#as">as</A> &quot;<A HREF="#:ab">:ab</A>&quot;, but no remapping for this <A HREF="#{rhs}">{rhs}</A>


						*<A NAME=":ca"></A><B>:ca</B>* *<A NAME=":cabbrev"></A><B>:cabbrev</B>*
:ca[bbrev] [&lt;expr&gt;] [&lt;buffer&gt;] [lhs] [rhs]
			same <A HREF="motion.html#as">as</A> &quot;<A HREF="#:ab">:ab</A>&quot;, but for <A HREF="cmdline.html#Command-line">Command-line</A> mode only.


						*<A NAME=":cuna"></A><B>:cuna</B>* *<A NAME=":cunabbrev"></A><B>:cunabbrev</B>*
:cuna[bbrev] <A HREF="#{lhs}">{lhs}</A>	same <A HREF="motion.html#as">as</A> &quot;<A HREF="#:una">:una</A>&quot;, but for <A HREF="cmdline.html#Command-line">Command-line</A> mode only.


						*<A NAME=":cnorea"></A><B>:cnorea</B>* *<A NAME=":cnoreabbrev"></A><B>:cnoreabbrev</B>*
:cnorea[bbrev] [&lt;expr&gt;] [&lt;buffer&gt;] [lhs] [rhs]
			same <A HREF="motion.html#as">as</A> &quot;<A HREF="#:ab">:ab</A>&quot;, but for <A HREF="cmdline.html#Command-line">Command-line</A> mode only and no
			remapping for this <A HREF="#{rhs}">{rhs}</A>


						*<A NAME=":ia"></A><B>:ia</B>* *<A NAME=":iabbrev"></A><B>:iabbrev</B>*
:ia[bbrev] [&lt;expr&gt;] [&lt;buffer&gt;] [lhs] [rhs]
			same <A HREF="motion.html#as">as</A> &quot;<A HREF="#:ab">:ab</A>&quot;, but for <A HREF="insert.html#Insert">Insert</A> mode only.


						*<A NAME=":iuna"></A><B>:iuna</B>* *<A NAME=":iunabbrev"></A><B>:iunabbrev</B>*
:iuna[bbrev] <A HREF="#{lhs}">{lhs}</A>	same <A HREF="motion.html#as">as</A> &quot;<A HREF="#:una">:una</A>&quot;, but for insert mode only.


						*<A NAME=":inorea"></A><B>:inorea</B>* *<A NAME=":inoreabbrev"></A><B>:inoreabbrev</B>*
:inorea[bbrev] [&lt;expr&gt;] [&lt;buffer&gt;] [lhs] [rhs]
			same <A HREF="motion.html#as">as</A> &quot;<A HREF="#:ab">:ab</A>&quot;, but for <A HREF="insert.html#Insert">Insert</A> mode only and no
			remapping for this <A HREF="#{rhs}">{rhs}</A>


							*<A NAME=":abc"></A><B>:abc</B>* *<A NAME=":abclear"></A><B>:abclear</B>*
:abc[lear] [&lt;buffer&gt;]	Remove all <A HREF="#abbreviations">abbreviations</A>.


							*<A NAME=":iabc"></A><B>:iabc</B>* *<A NAME=":iabclear"></A><B>:iabclear</B>*
:iabc[lear] [&lt;buffer&gt;]	Remove all <A HREF="#abbreviations">abbreviations</A> for <A HREF="insert.html#Insert">Insert</A> mode.


							*<A NAME=":cabc"></A><B>:cabc</B>* *<A NAME=":cabclear"></A><B>:cabclear</B>*
:cabc[lear] [&lt;buffer&gt;]	Remove all <A HREF="#abbreviations">abbreviations</A> for <A HREF="cmdline.html#Command-line">Command-line</A> mode.


							*<A NAME="using_CTRL-V"></A><B>using_CTRL-V</B>*
It is possible to use special characters in the rhs of an abbreviation.
<A HREF="visual.html#CTRL-V">CTRL-V</A> has to be used to avoid the special meaning of most non printable
characters.  How many CTRL-Vs need to be typed depends on how you enter the
abbreviation.  This also applies to mappings.  Let's use an example here.

Suppose you want to abbreviate &quot;esc&quot; to enter an <A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A> character.  When you
type the &quot;<A HREF="#:ab">:ab</A>&quot; command in Vim, you have to enter this: (here ^V is a <A HREF="visual.html#CTRL-V">CTRL-V</A>
and ^[ is <A HREF="intro.html#&lt;Esc&gt;">&lt;Esc&gt;</A>)

You type:   <A HREF="motion.html#ab">ab</A> esc ^V^V^V^V^V^[

	All keyboard input is subjected to ^V <A HREF="change.html#quote">quote</A> interpretation, so
	the first, third, and fifth ^V  characters simply allow the second,
	and fourth ^Vs, and the ^[, to be entered into the command-line.

You see:    <A HREF="motion.html#ab">ab</A> esc ^V^V^[

	The command-line contains two actual ^Vs before the ^[.  This is
	how <A HREF="motion.html#it">it</A> should appear in your <A HREF="starting.html#vimrc">vimrc</A> file, if you choose to go that
	route.  The first ^V is there to <A HREF="change.html#quote">quote</A> the second ^V; the <A HREF="#:ab">:ab</A>
	command uses ^V <A HREF="motion.html#as">as</A> its own <A HREF="change.html#quote">quote</A> character, so you can include quoted
	<A HREF="pattern.html#whitespace">whitespace</A> or the &#124; character in the abbreviation.  The <A HREF="#:ab">:ab</A> command
	doesn't <A HREF="diff.html#do">do</A> anything special with the ^[ character, so <A HREF="motion.html#it">it</A> doesn't need
	to be quoted.  (Although quoting isn't harmful; that's why typing 7
	[but not 8!] ^Vs works.)

Stored <A HREF="motion.html#as">as</A>:  esc     ^V^[

	After parsing, the abbreviation's short form (&quot;esc&quot;) and long form
	(the two characters &quot;^V^[&quot;) are stored in the abbreviation table.
	If you give the <A HREF="#:ab">:ab</A> command with no arguments, this is how the
	abbreviation will be displayed.

	Later, when the abbreviation is expanded because the user typed in
	the <A HREF="motion.html#word">word</A> &quot;esc&quot;, the long form is subjected to the same type of
	^V interpretation <A HREF="motion.html#as">as</A> keyboard input.  So the ^V protects the ^[
	character from being interpreted <A HREF="motion.html#as">as</A> the &quot;exit <A HREF="insert.html#Insert">Insert</A> mode&quot; character.
	Instead, the ^[ is inserted into the text.

Expands to: ^[

[example given by Steve Kirkendall]

==============================================================================

3. Local mappings and <A HREF="eval.html#functions">functions</A>				*<A NAME="script-local"></A><B>script-local</B>*

When using several Vim <A HREF="usr_41.html#script">script</A> files, there is the danger that mappings and
<A HREF="eval.html#functions">functions</A> used in one <A HREF="usr_41.html#script">script</A> use the same name <A HREF="motion.html#as">as</A> in other scripts.  To avoid
this, they can be made local to the <A HREF="usr_41.html#script">script</A>.


						*<A NAME="&lt;SID&gt;"></A><B>&lt;SID&gt;</B>* *<A NAME="&lt;SNR&gt;"></A><B>&lt;SNR&gt;</B>* *<A NAME="E81"></A><B>E81</B>*
The <A HREF="eval.html#string">string</A> &quot;<A HREF="#&lt;SID&gt;">&lt;SID&gt;</A>&quot; can be used in a <A HREF="#mapping">mapping</A> or menu.
   When executing the map command, Vim will replace &quot;<A HREF="#&lt;SID&gt;">&lt;SID&gt;</A>&quot; with the special
key code <A HREF="#&lt;SNR&gt;">&lt;SNR&gt;</A>, followed by a number that's unique for the <A HREF="usr_41.html#script">script</A>, and an
underscore.  Example:
<B>	:map &lt;SID&gt;Add</B>
could define a <A HREF="#mapping">mapping</A> &quot;&lt;SNR&gt;23_Add&quot;.

When defining a function in a <A HREF="usr_41.html#script">script</A>, &quot;s:&quot; can be prepended to the name to
make <A HREF="motion.html#it">it</A> local to the <A HREF="usr_41.html#script">script</A>.  But when a <A HREF="#mapping">mapping</A> is executed from outside of
the <A HREF="usr_41.html#script">script</A>, <A HREF="motion.html#it">it</A> doesn't know in which <A HREF="usr_41.html#script">script</A> the function was defined.  To
avoid this problem, use &quot;<A HREF="#&lt;SID&gt;">&lt;SID&gt;</A>&quot; instead of &quot;s:&quot;.  The same translation is done
<A HREF="motion.html#as">as</A> for mappings.  This makes <A HREF="motion.html#it">it</A> possible to define a call to the function in
a <A HREF="#mapping">mapping</A>.

When a local function is executed, <A HREF="motion.html#it">it</A> runs in the context of the <A HREF="usr_41.html#script">script</A> <A HREF="motion.html#it">it</A> was
defined in.  This means that new <A HREF="eval.html#functions">functions</A> and mappings <A HREF="motion.html#it">it</A> defines can also
use &quot;s:&quot; or &quot;<A HREF="#&lt;SID&gt;">&lt;SID&gt;</A>&quot; and <A HREF="motion.html#it">it</A> will use the same unique number <A HREF="motion.html#as">as</A> when the
function itself was defined.  Also, the &quot;<A HREF="eval.html#s:var">s:var</A>&quot; local <A HREF="usr_41.html#script">script</A> <A HREF="eval.html#variables">variables</A> can be
used.

When executing an <A HREF="autocmd.html#autocommand">autocommand</A> or a user command, <A HREF="motion.html#it">it</A> will run in the context of
the <A HREF="usr_41.html#script">script</A> <A HREF="motion.html#it">it</A> was defined in.  This makes <A HREF="motion.html#it">it</A> possible that the command calls a
local function or uses a local <A HREF="#mapping">mapping</A>.

Otherwise, using &quot;<A HREF="#&lt;SID&gt;">&lt;SID&gt;</A>&quot; outside of a <A HREF="usr_41.html#script">script</A> context is an error.

If you need to get the <A HREF="usr_41.html#script">script</A> number to use in a complicated <A HREF="usr_41.html#script">script</A>, you can
use this function:
<B>	function s:SID()</B>
<B>	  return matchstr(expand('&lt;sfile&gt;'), '&lt;SNR&gt;\zs\d\+\ze_SID$')</B>
<B>	endfun</B>

The &quot;<A HREF="#&lt;SNR&gt;">&lt;SNR&gt;</A>&quot; will be shown when listing <A HREF="eval.html#functions">functions</A> and mappings.  This is useful
to find out what they are defined to.

The |<A HREF="repeat.html#:scriptnames">:scriptnames</A>| command can be used to see which scripts have been sourced
and what their <A HREF="#&lt;SNR&gt;">&lt;SNR&gt;</A> number is.

==============================================================================

4. User-defined commands				*<A NAME="user-commands"></A><B>user-commands</B>*

It is possible to define your own <A HREF="intro.html#Ex">Ex</A> commands.  A user-defined command can act
just like a built-in command (it can have a range or arguments, arguments can
be completed <A HREF="motion.html#as">as</A> filenames or buffer names, etc), except that when the command
is executed, <A HREF="motion.html#it">it</A> is transformed into a normal <A HREF="intro.html#Ex">Ex</A> command and then executed.

For starters: See section |<A HREF="usr_40.html#40.2">40.2</A>| in the user manual.


					*<A NAME="E183"></A><B>E183</B>* *<A NAME="E841"></A><B>E841</B>* *<A NAME="user-cmd-ambiguous"></A><B>user-cmd-ambiguous</B>*
All user defined commands must start with an <A HREF="change.html#uppercase">uppercase</A> <A HREF="print.html#letter">letter</A>, to avoid
confusion with builtin commands.  Exceptions are these builtin commands:
	<A HREF="editing.html#:Next">:Next</A>
They cannot be used for a user defined command.

The other characters of the user command can be <A HREF="change.html#uppercase">uppercase</A> letters, <A HREF="change.html#lowercase">lowercase</A>
letters or digits.  When using digits, note that other commands that take a
numeric argument may become ambiguous.  For example, the command &quot;:Cc2&quot; could
be the user command &quot;:Cc2&quot; without an argument, or the command &quot;:Cc&quot; with
argument &quot;2&quot;.  It is advised to put a space between the command name and the
argument to avoid these problems.

When using a user-defined command, the command can be abbreviated.  However, if
an abbreviation is not unique, an error will be issued.  Furthermore, a
built-in command will always take precedence.

Example:
<B>	:command Rename ...</B>
<B>	:command Renumber ...</B>
<B>	:Rena				" Means "Rename"</B>
<B>	:Renu				" Means "Renumber"</B>
<B>	:Ren				" Error - ambiguous</B>
<B>	:command Paste ...</B>

It is recommended that full names for user-defined commands are used in
scripts.


:com[mand]						*<A NAME=":com"></A><B>:com</B>* *<A NAME=":command"></A><B>:command</B>*
			<A HREF="eval.html#List">List</A> all user-defined commands.  When listing commands,
			the characters in the first two columns are
			    !	Command has the -bang attribute
			    &quot;	Command has the -register attribute
			    <A HREF="motion.html#b">b</A>	Command is local to current buffer
			(see below for details on attributes)
			The <A HREF="eval.html#list">list</A> can be filtered on command name with
			|<A HREF="various.html#:filter">:filter</A>|, e.g., to <A HREF="eval.html#list">list</A> all commands with &quot;Pyth&quot; in
			the name:
<B>				filter Pyth command</B>

:com[mand] {cmd}	<A HREF="eval.html#List">List</A> the user-defined commands that start with {cmd}


							*<A NAME=":command-verbose"></A><B>:command-verbose</B>*
When <A HREF="options.html#'verbose'">'verbose'</A> is non-zero, listing a command will also display where <A HREF="motion.html#it">it</A> was
last defined. Example:

<B>    :verbose command TOhtml</B>
<B><FONT color="#54A23D"> 	Name	    Args Range Complete  Definition </FONT></B>
<B><FONT color="#54A23D">	TOhtml	    0	 %		 :call Convert2HTML(&lt;line1&gt;, &lt;line2&gt;) </FONT></B>
<B><FONT color="#54A23D">	    Last set from /usr/share/vim/vim-7.0/plugin/tohtml.vim </FONT></B>

See |<A HREF="various.html#:verbose-cmd">:verbose-cmd</A>| for more information.


							*<A NAME="E174"></A><B>E174</B>* *<A NAME="E182"></A><B>E182</B>*
:com[mand][!] [{attr}...] {cmd} {rep}
			Define a user command.  The name of the command is
			{cmd} and its replacement text is {rep}.  The command's
			attributes (see below) are {attr}.  If the command
			already exists, an error is reported, unless a ! is
			specified, in which <A HREF="change.html#case">case</A> the command is redefined.


:delc[ommand] {cmd}				*<A NAME=":delc"></A><B>:delc</B>* *<A NAME=":delcommand"></A><B>:delcommand</B>* *<A NAME="E184"></A><B>E184</B>*
			Delete the user-defined command {cmd}.


:comc[lear]						*<A NAME=":comc"></A><B>:comc</B>* *<A NAME=":comclear"></A><B>:comclear</B>*
			Delete all user-defined commands.

Command attributes

User-defined commands are treated by Vim just like any other <A HREF="intro.html#Ex">Ex</A> commands.  They
can have arguments, or have a range specified.  Arguments are subject to
completion <A HREF="motion.html#as">as</A> filenames, <A HREF="windows.html#buffers">buffers</A>, etc.  Exactly how this works depends upon the
command's attributes, which are specified when the command is defined.

There are a number of attributes, split into four categories: argument
handling, completion behavior, range handling, and special cases.  The
attributes are described below, by category.


Argument handling				*<A NAME="E175"></A><B>E175</B>* *<A NAME="E176"></A><B>E176</B>* *<A NAME=":command-nargs"></A><B>:command-nargs</B>*

By default, a user defined command will take no arguments (and an error is
reported if any are supplied).  However, <A HREF="motion.html#it">it</A> is possible to specify that the
command can take arguments, using the -nargs attribute.  Valid cases are:

	-nargs=0    No arguments are allowed (the default)
	-nargs=1    Exactly one argument is required, <A HREF="motion.html#it">it</A> includes spaces 
	-nargs=*    Any number of arguments are allowed (0, 1, or many),
		    separated by white space
	-nargs=?    0 or 1 arguments are allowed
	-nargs=+    Arguments must be supplied, but any number are allowed

Arguments are considered to be separated by (unescaped) spaces or tabs in this
context, except when there is one argument, then the white space is part of
the argument.

Note that arguments are used <A HREF="motion.html#as">as</A> text, not <A HREF="motion.html#as">as</A> expressions.  Specifically,
&quot;<A HREF="eval.html#s:var">s:var</A>&quot; will use the <A HREF="#script-local">script-local</A> variable in the <A HREF="usr_41.html#script">script</A> where the command was
defined, not where <A HREF="motion.html#it">it</A> is invoked!  Example:
    script1.vim:
<B>	:let s:error = "None"</B>
<B>	:command -nargs=1 Error echoerr &lt;args&gt;</B>
    script2.vim:
<B>	:source script1.vim</B>
<B>	:let s:error = "Wrong!"</B>
<B>	:Error s:error</B>
Executing script2.vim will result in &quot;None&quot; being echoed.  Not what you
intended!  Calling a function may be an alternative.


Completion behavior				*<A NAME=":command-completion"></A><B>:command-completion</B>* *<A NAME="E179"></A><B>E179</B>*

					*<A NAME="E180"></A><B>E180</B>* *<A NAME="E181"></A><B>E181</B>* *<A NAME=":command-complete"></A><B>:command-complete</B>*
By default, the arguments of user defined commands <A HREF="diff.html#do">do</A> not undergo completion.
However, by specifying one or the other of the following attributes, argument
completion can be enabled:

	-complete=augroup	autocmd groups
	-complete=buffer	buffer names
	-complete=behave	<A HREF="gui.html#:behave">:behave</A> suboptions
	-complete=color		color schemes
	-complete=command	<A HREF="intro.html#Ex">Ex</A> command (and arguments)
	-complete=compiler	compilers
	-complete=cscope	|<A HREF="if_cscop.html#:cscope">:cscope</A>| suboptions
	-complete=dir		directory names
	-complete=environment	environment variable names
	-complete=event		<A HREF="autocmd.html#autocommand">autocommand</A> events
	-complete=expression	Vim <A HREF="eval.html#expression">expression</A>
	-complete=file		file and directory names
	-complete=file_in_path	file and directory names in |<A HREF="options.html#'path'">'path'</A>|
	-complete=filetype	filetype names |<A HREF="options.html#'filetype'">'filetype'</A>|
	-complete=function	function name
	-complete=help		help subjects
	-complete=highlight	highlight groups
	-complete=history	<A HREF="cmdline.html#:history">:history</A> suboptions
	-complete=locale	<A HREF="mbyte.html#locale">locale</A> names (as output of <A HREF="mbyte.html#locale">locale</A> -a)
	-complete=mapping	<A HREF="#mapping">mapping</A> name
	-complete=menu		<A HREF="gui.html#menus">menus</A>
	-complete=messages	|<A HREF="message.html#:messages">:messages</A>| suboptions
	-complete=option	<A HREF="options.html#options">options</A>
	-complete=packadd	optional package |<A HREF="repeat.html#pack-add">pack-add</A>| names
	-complete=shellcmd	Shell command
	-complete=sign		|<A HREF="sign.html#:sign">:sign</A>| suboptions
	-complete=syntax	syntax file names |<A HREF="options.html#'syntax'">'syntax'</A>|
	-complete=syntime	|<A HREF="syntax.html#:syntime">:syntime</A>| suboptions
	-complete=tag		<A HREF="tagsrch.html#tags">tags</A>
	-complete=tag_listfiles	<A HREF="tagsrch.html#tags">tags</A>, file names are shown when <A HREF="scroll.html#CTRL-D">CTRL-D</A> is hit
	-complete=user		user names
	-complete=var		user <A HREF="eval.html#variables">variables</A>
	-complete=custom,{func} custom completion, defined via {func}
	-complete=customlist,{func} custom completion, defined via {func}

Note: That some completion methods might expand environment <A HREF="eval.html#variables">variables</A>.



Custom completion			*<A NAME=":command-completion-custom"></A><B>:command-completion-custom</B>*

					*<A NAME=":command-completion-customlist"></A><B>:command-completion-customlist</B>*

					*<A NAME="E467"></A><B>E467</B>* *<A NAME="E468"></A><B>E468</B>*
It is possible to define customized completion schemes via the &quot;custom,{func}&quot;
or the &quot;customlist,{func}&quot; completion argument.  The {func} part should be a
function with the following signature:

<B>	:function {func}(ArgLead, CmdLine, CursorPos)</B>

The function need not use all these arguments. The function should provide the
completion candidates <A HREF="motion.html#as">as</A> the return value.

For the &quot;custom&quot; argument, the function should return the completion
candidates one per line in a newline separated <A HREF="eval.html#string">string</A>.

For the &quot;customlist&quot; argument, the function should return the completion
candidates <A HREF="motion.html#as">as</A> a Vim <A HREF="eval.html#List">List</A>.  Non-string items in the <A HREF="eval.html#list">list</A> are ignored.

The function arguments are:
	ArgLead		the leading portion of the argument currently being
			completed on
	CmdLine		the entire command line
	CursorPos	the cursor position in <A HREF="motion.html#it">it</A> (byte index)
The function may use these for determining context.  For the &quot;custom&quot;
argument, <A HREF="motion.html#it">it</A> is not necessary to <A HREF="change.html#filter">filter</A> candidates against the (implicit
<A HREF="pattern.html#pattern">pattern</A> in) ArgLead.  Vim will <A HREF="change.html#filter">filter</A> the candidates with its <A HREF="pattern.html#regexp">regexp</A> engine
after function return, and this is probably more efficient in most cases. For
the &quot;customlist&quot; argument, Vim will not <A HREF="change.html#filter">filter</A> the returned completion
candidates and the user supplied function should <A HREF="change.html#filter">filter</A> the candidates.

The following example lists user names to a Finger command
<B>    :com -complete=custom,ListUsers -nargs=1 Finger !finger &lt;args&gt;</B>
<B>    :fun ListUsers(A,L,P)</B>
<B>    :    return system("cut -d: -f1 /etc/passwd")</B>
<B>    :endfun</B>

The following example completes filenames from the directories specified in
the <A HREF="options.html#'path'">'path'</A> option:
<B>    :com -nargs=1 -bang -complete=customlist,EditFileComplete</B>
<B>			\ EditFile edit&lt;bang&gt; &lt;args&gt;</B>
<B>    :fun EditFileComplete(A,L,P)</B>
<B>    :    return split(globpath(&amp;path, a:A), "\n")</B>
<B>    :endfun</B>
 
This example does not work for file names with spaces!



Range handling				*<A NAME="E177"></A><B>E177</B>* *<A NAME="E178"></A><B>E178</B>* *<A NAME=":command-range"></A><B>:command-range</B>*

							*<A NAME=":command-count"></A><B>:command-count</B>*
By default, user-defined commands <A HREF="diff.html#do">do</A> not accept a line number range.  However,
<A HREF="motion.html#it">it</A> is possible to specify that the command does take a range (the -range
attribute), or that <A HREF="motion.html#it">it</A> takes an arbitrary <A HREF="intro.html#count">count</A> value, either in the line
number position (-range=N, like the |<A HREF="windows.html#:split">:split</A>| command) or <A HREF="motion.html#as">as</A> a &quot;<A HREF="intro.html#count">count</A>&quot;
argument (-count=N, like the |<A HREF="editing.html#:Next">:Next</A>| command).  The <A HREF="intro.html#count">count</A> will then be
available in the argument with |<A HREF="#&lt;count&gt;">&lt;count&gt;</A>|.

Possible attributes are:

	-range	    Range allowed, default is current line
	-range=&#37;    Range allowed, default is whole file (1,$)
	-range=N    A <A HREF="intro.html#count">count</A> (default N) which is specified in the line
		    number position (like |<A HREF="windows.html#:split">:split</A>|); allows for zero line
		    number.
	-count=N    A <A HREF="intro.html#count">count</A> (default N) which is specified either in the line
		    number position, or <A HREF="motion.html#as">as</A> an initial argument (like |<A HREF="editing.html#:Next">:Next</A>|).
		    Specifying -count (without a default) acts like -count=0

Note that -range=N and -count=N are mutually <A HREF="motion.html#exclusive">exclusive</A> - only one should be
specified.


                                                  *<A NAME=":command-addr"></A><B>:command-addr</B>*
It is possible that the special characters in the range like `.`, `$` or `&#37;`
which by default correspond to the current line, last line and the whole
buffer, relate to arguments, (loaded) <A HREF="windows.html#buffers">buffers</A>, <A HREF="windows.html#windows">windows</A> or <A HREF="intro.html#tab">tab</A> pages.

Possible values are:
     -addr=lines            Range of lines (this is the default)
     -addr=arguments        Range for arguments
     -addr=buffers          Range for <A HREF="windows.html#buffers">buffers</A> (also not loaded <A HREF="windows.html#buffers">buffers</A>)
     -addr=loaded_buffers   Range for loaded <A HREF="windows.html#buffers">buffers</A>
     -addr=windows          Range for <A HREF="windows.html#windows">windows</A>
     -addr=tabs             Range for <A HREF="intro.html#tab">tab</A> pages



Special cases				*<A NAME=":command-bang"></A><B>:command-bang</B>* *<A NAME=":command-bar"></A><B>:command-bar</B>*

					*<A NAME=":command-register"></A><B>:command-register</B>* *<A NAME=":command-buffer"></A><B>:command-buffer</B>*
There are some special cases <A HREF="motion.html#as">as</A> well:

	-bang	    The command can take a ! modifier (like <A HREF="editing.html#:q">:q</A> or <A HREF="editing.html#:w">:w</A>)
	-bar	    The command can be followed by a &quot;|&quot; and another command.
		    A &quot;|&quot; inside the command argument is not allowed then.
		    Also checks for a &quot; to start a comment.
	-register   The first argument to the command can be an optional
		    <A HREF="sponsor.html#register">register</A> name (like <A HREF="change.html#:del">:del</A>, <A HREF="change.html#:put">:put</A>, <A HREF="change.html#:yank">:yank</A>).
	-buffer	    The command will only be available in the current buffer.

In the cases of the -count and -register attributes, if the optional argument
is supplied, <A HREF="motion.html#it">it</A> is removed from the argument <A HREF="eval.html#list">list</A> and is available to the
replacement text separately.
Note that these arguments can be abbreviated, but that is a <A HREF="deprecated.html#deprecated">deprecated</A>
feature.  Use the full name for new scripts.

Replacement text

The replacement text for a user defined command is scanned for special <A HREF="intro.html#escape">escape</A>
sequences, using &lt;...&gt; <A HREF="intro.html#notation">notation</A>.  Escape sequences are replaced with values
from the entered command line, and all other text is copied unchanged.  The
resulting <A HREF="eval.html#string">string</A> is executed <A HREF="motion.html#as">as</A> an <A HREF="intro.html#Ex">Ex</A> command.  To avoid the replacement use
<A HREF="intro.html#&lt;lt&gt;">&lt;lt&gt;</A> in place of the initial <A HREF="change.html#&lt;">&lt;</A>.  Thus to include &quot;<A HREF="#&lt;bang&gt;">&lt;bang&gt;</A>&quot; literally use
&quot;&lt;lt&gt;bang&gt;&quot;.

The valid <A HREF="intro.html#escape">escape</A> sequences are


						*<A NAME="&lt;line1&gt;"></A><B>&lt;line1&gt;</B>*
	<A HREF="#&lt;line1&gt;">&lt;line1&gt;</A>	The starting line of the command range.

						*<A NAME="&lt;line2&gt;"></A><B>&lt;line2&gt;</B>*
	<A HREF="#&lt;line2&gt;">&lt;line2&gt;</A>	The final line of the command range.

						*<A NAME="&lt;count&gt;"></A><B>&lt;count&gt;</B>*
	<A HREF="#&lt;count&gt;">&lt;count&gt;</A>	Any <A HREF="intro.html#count">count</A> supplied (as described for the '-range'
		and '-count' attributes).

						*<A NAME="&lt;bang&gt;"></A><B>&lt;bang&gt;</B>*
	<A HREF="#&lt;bang&gt;">&lt;bang&gt;</A>	(See the '-bang' attribute) Expands to a ! if the
		command was executed with a ! modifier, otherwise
		expands to nothing.

						*<A NAME="&lt;mods&gt;"></A><B>&lt;mods&gt;</B>*
	<A HREF="#&lt;mods&gt;">&lt;mods&gt;</A>  The command modifiers, if specified. Otherwise, expands to
		nothing. Supported modifiers are |<A HREF="windows.html#:aboveleft">:aboveleft</A>|, |<A HREF="windows.html#:belowright">:belowright</A>|,
		|<A HREF="windows.html#:botright">:botright</A>|, |<A HREF="editing.html#:browse">:browse</A>|, |<A HREF="editing.html#:confirm">:confirm</A>|, |<A HREF="windows.html#:hide">:hide</A>|, |<A HREF="editing.html#:keepalt">:keepalt</A>|,
		|<A HREF="motion.html#:keepjumps">:keepjumps</A>|, |<A HREF="motion.html#:keepmarks">:keepmarks</A>|, |<A HREF="cmdline.html#:keeppatterns">:keeppatterns</A>|, |<A HREF="windows.html#:leftabove">:leftabove</A>|,
		|<A HREF="motion.html#:lockmarks">:lockmarks</A>|, |<A HREF="recover.html#:noswapfile">:noswapfile</A>| |<A HREF="windows.html#:rightbelow">:rightbelow</A>|, |<A HREF="various.html#:silent">:silent</A>|, |<A HREF="tabpage.html#:tab">:tab</A>|,
		|<A HREF="windows.html#:topleft">:topleft</A>|, |<A HREF="various.html#:verbose">:verbose</A>|, and |<A HREF="windows.html#:vertical">:vertical</A>|.
		Note that these are not yet supported: |<A HREF="autocmd.html#:noautocmd">:noautocmd</A>|,
		|<A HREF="eval.html#:sandbox">:sandbox</A>| and |<A HREF="various.html#:unsilent">:unsilent</A>|.
		Examples:
<B>		    command! -nargs=+ -complete=file MyEdit</B>
<B>				\ for f in expand(&lt;q-args&gt;, 0, 1) |</B>
<B>				\ exe '&lt;mods&gt; split ' . f |</B>
<B>				\ endfor</B>

<B>		    function! SpecialEdit(files, mods)</B>
<B>			for f in expand(a:files, 0, 1)</B>
<B>			    exe a:mods . ' split ' . f</B>
<B>			endfor</B>
<B>		    endfunction</B>
<B>		    command! -nargs=+ -complete=file Sedit</B>
<B>				\ call SpecialEdit(&lt;q-args&gt;, &lt;q-mods&gt;)</B>
 

						*<A NAME="&lt;reg&gt;"></A><B>&lt;reg&gt;</B>* *<A NAME="&lt;register&gt;"></A><B>&lt;register&gt;</B>*
	<A HREF="#&lt;reg&gt;">&lt;reg&gt;</A>	(See the '-register' attribute) The optional <A HREF="sponsor.html#register">register</A>,
		if specified.  Otherwise, expands to nothing.  <A HREF="#&lt;register&gt;">&lt;register&gt;</A>
		is a synonym for this.

						*<A NAME="&lt;args&gt;"></A><B>&lt;args&gt;</B>*
	<A HREF="#&lt;args&gt;">&lt;args&gt;</A>	The command arguments, exactly <A HREF="motion.html#as">as</A> supplied (but <A HREF="motion.html#as">as</A>
		noted above, any <A HREF="intro.html#count">count</A> or <A HREF="sponsor.html#register">register</A> can consume some
		of the arguments, which are then not part of <A HREF="#&lt;args&gt;">&lt;args&gt;</A>).
	<A HREF="intro.html#&lt;lt&gt;">&lt;lt&gt;</A>	A single '<A HREF="change.html#&lt;">&lt;</A>' (Less-Than) character.  This is needed if you
		want to get a literal copy of one of these <A HREF="intro.html#escape">escape</A> sequences
		into the expansion - for example, to get <A HREF="#&lt;bang&gt;">&lt;bang&gt;</A>, use
		&lt;lt&gt;bang&gt;.


							*<A NAME="&lt;q-args&gt;"></A><B>&lt;q-args&gt;</B>*
If the first two characters of an <A HREF="intro.html#escape">escape</A> sequence are &quot;q-&quot; (for example,
<A HREF="#&lt;q-args&gt;">&lt;q-args&gt;</A>) then the value is quoted in such a way <A HREF="motion.html#as">as</A> to make <A HREF="motion.html#it">it</A> a valid value
for use in an <A HREF="eval.html#expression">expression</A>.  This uses the argument <A HREF="motion.html#as">as</A> one single value.
When there is no argument <A HREF="#&lt;q-args&gt;">&lt;q-args&gt;</A> is an empty <A HREF="eval.html#string">string</A>.

							*<A NAME="&lt;f-args&gt;"></A><B>&lt;f-args&gt;</B>*
To allow commands to pass their arguments on to a user-defined function, there
is a special form <A HREF="#&lt;f-args&gt;">&lt;f-args&gt;</A> (&quot;function args&quot;).  This splits the command
arguments at spaces and tabs, quotes each argument individually, and the
<A HREF="#&lt;f-args&gt;">&lt;f-args&gt;</A> sequence is replaced by the comma-separated <A HREF="eval.html#list">list</A> of quoted arguments.
See the Mycmd example below.  If no arguments are given <A HREF="#&lt;f-args&gt;">&lt;f-args&gt;</A> is removed.
   To embed <A HREF="pattern.html#whitespace">whitespace</A> into an argument of <A HREF="#&lt;f-args&gt;">&lt;f-args&gt;</A>, prepend a <A HREF="intro.html#backslash">backslash</A>.
<A HREF="#&lt;f-args&gt;">&lt;f-args&gt;</A> replaces every pair of backslashes (\\) with one <A HREF="intro.html#backslash">backslash</A>.  A
<A HREF="intro.html#backslash">backslash</A> followed by a character other than white space or a <A HREF="intro.html#backslash">backslash</A>
remains unmodified.  Overview:

<B><FONT color="#54A23D">	command		   &lt;f-args&gt; </FONT></B>
	XX <A HREF="motion.html#ab">ab</A>		   '<A HREF="motion.html#ab">ab</A>'
	XX a\b		   'a\b'
	XX a\ <A HREF="motion.html#b">b</A>		   <A HREF="motion.html#'a">'a</A> b'
	XX a\  <A HREF="motion.html#b">b</A>	   <A HREF="motion.html#'a">'a</A> '', '<A HREF="motion.html#b">b</A>'
	XX a\\b		   'a\b'
	XX a\\ <A HREF="motion.html#b">b</A>	   'a\', '<A HREF="motion.html#b">b</A>'
	XX a\\\b	   'a\\b'
	XX a\\\ <A HREF="motion.html#b">b</A>	   'a\ b'
	XX a\\\\b	   'a\\b'
	XX a\\\\ <A HREF="motion.html#b">b</A>	   'a\\', '<A HREF="motion.html#b">b</A>'

Examples

<B>   " Delete everything after here to the end</B>
<B>   :com Ddel +,$d</B>

<B>   " Rename the current buffer</B>
<B>   :com -nargs=1 -bang -complete=file Ren f &lt;args&gt;|w&lt;bang&gt;</B>

<B>   " Replace a range with the contents of a file</B>
<B>   " (Enter this all as one line)</B>
<B>   :com -range -nargs=1 -complete=file</B>
<B>	 Replace &lt;line1&gt;-pu_|&lt;line1&gt;,&lt;line2&gt;d|r &lt;args&gt;|&lt;line1&gt;d</B>

<B>   " Count the number of lines in the range</B>
<B>   :com! -range -nargs=0 Lines  echo &lt;line2&gt; - &lt;line1&gt; + 1 "lines"</B>

<B>   " Call a user function (example of &lt;f-args&gt;)</B>
<B>   :com -nargs=* Mycmd call Myfunc(&lt;f-args&gt;)</B>

When executed <A HREF="motion.html#as">as</A>:
<B>	:Mycmd arg1 arg2</B>
This will invoke:
<B>	:call Myfunc("arg1","arg2")</B>

<B>   :" A more substantial example</B>
<B>   :function Allargs(command)</B>
<B>   :   let i = 0</B>
<B>   :   while i &lt; argc()</B>
<B>   :	  if filereadable(argv(i))</B>
<B>   :	     execute "e " . argv(i)</B>
<B>   :	     execute a:command</B>
<B>   :      endif</B>
<B>   :      let i = i + 1</B>
<B>   :   endwhile</B>
<B>   :endfunction</B>
<B>   :command -nargs=+ -complete=command Allargs call Allargs(&lt;q-args&gt;)</B>

The command Allargs takes any Vim command(s) <A HREF="motion.html#as">as</A> argument and executes <A HREF="motion.html#it">it</A> on all
files in the argument <A HREF="eval.html#list">list</A>.  Usage example (note use of the &quot;<A HREF="motion.html#e">e</A>&quot; flag to ignore
<A HREF="message.html#errors">errors</A> and the &quot;update&quot; command to write modified buffers):
<B>	:Allargs %s/foo/bar/ge|update</B>
This will invoke:
<B>	:call Allargs("%s/foo/bar/ge|update")</B>
 
When defining a user command in a <A HREF="usr_41.html#script">script</A>, <A HREF="motion.html#it">it</A> will be able to call <A HREF="eval.html#functions">functions</A>
local to the <A HREF="usr_41.html#script">script</A> and use mappings local to the <A HREF="usr_41.html#script">script</A>.  When the user
invokes the user command, <A HREF="motion.html#it">it</A> will run in the context of the <A HREF="usr_41.html#script">script</A> <A HREF="motion.html#it">it</A> was
defined in.  This matters if |<A HREF="#&lt;SID&gt;">&lt;SID&gt;</A>| is used in a command.

<A HREF="#top">top</A> - <A HREF="index.html">main help file</A>
</PRE>
    </div>
  <script data-cfasync="false" src="/cdn-cgi/scripts/d07b1474/cloudflare-static/email-decode.min.js"></script></body>
</html>
